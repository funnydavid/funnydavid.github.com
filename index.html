<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Narrater</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Narrater">
<meta property="og:url" content="http://inarrater.com/index.html">
<meta property="og:site_name" content="Narrater">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Narrater">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Narrater" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">董夕</a></h1>
		</hgroup>

		
		<p class="header-subtitle">讲述，而非记录</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/开发/" style="font-size: 20px;">开发</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">程序员，对故事有爱，想要有趣的人生。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">董夕</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">董夕</h1>
			</hgroup>
			
			<p class="header-subtitle">讲述，而非记录</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-pythonadvance5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/10/pythonadvance5/" class="article-date">
  	<time datetime="2016-07-10T13:03:25.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/pythonadvance5/">Python进阶(五)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="7-Function"><a href="#7-Function" class="headerlink" title="7. Function"></a>7. Function</h2><p>作为Callable部分第一个被提到，但是最后来分析它。原因其实很简单，我们已经发现前面的很多内容，包括bound method也好，static method也好，甚至operators，本质上都是function。<br>那么，如何去探究一个Python的Function的属性呢，阅读过前面内容的读者应该很明白了，通过一些简单的代码加上print就可以看到不少东西了。<br>我们先用dirf来看下一个function对象身上有什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b = <span class="number">10</span>)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(foo)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'func_closure'</span>, <span class="string">'func_code'</span>, <span class="string">'func_defaults'</span>, <span class="string">'func_dict'</span>, <span class="string">'func_doc'</span>, <span class="string">'func_globals'</span>, <span class="string">'func_name'</span>]</span><br></pre></td></tr></table></figure></p>
<p>不管双下划线开头的部分属性，我们只看对外开放的部分，先来看一看func_name属性吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> foo       <span class="comment">#&lt;function foo at 0x0235A2B0&gt;</span></span><br><span class="line">foo.func_name = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">print</span> foo       &lt;function abc at <span class="number">0x0235A2B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>func_name看上只是用来记录信息的一个名称而已，修改它并不会影响函数对象的调用。<br>我们再来看下func_defaults属性，看名称它是和默认值相关。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)			<span class="comment">#11</span></span><br><span class="line"><span class="keyword">print</span> foo.func_defaults		<span class="comment">#(10,)</span></span><br><span class="line">foo.func_defaults = (<span class="number">100</span>, )</span><br><span class="line">foo(<span class="number">1</span>)			<span class="comment">#101</span></span><br></pre></td></tr></table></figure></p>
<p>依然是把输出的结果放在代码行的后面以注释的形式给出，我们看到函数对象的func_defaults属性是一个元组，依次列出了所有默认参数。我们可以通过改变这个属性来改变已经被定义了的函数的默认参数。<br>为了可以看到func_closture的内容，我们构建一个闭包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> x + n</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">	</span><br><span class="line">f = bar(<span class="number">1</span>)</span><br><span class="line">g = bar(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">2</span>)		<span class="comment"># 3</span></span><br><span class="line"><span class="keyword">print</span> g(<span class="string">"def"</span>)	<span class="comment"># defabc</span></span><br><span class="line"><span class="keyword">print</span> foo.func_closure	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> f.func_closure	<span class="comment"># (&lt;cell at 0x029655F0: int object at 0x029378E0&gt;,)</span></span><br><span class="line"><span class="keyword">print</span> g.func_closure	<span class="comment"># (&lt;cell at 0x02A31130: str object at 0x02972AE8&gt;,)</span></span><br></pre></td></tr></table></figure></p>
<p>f和g是两个闭包对象，可以看到foo这个函数对象身上的func_closure属性为None，f和g身上分别是两个cell对象，这部分内容和闭包中讲的部分就契合在了一起。<br>func_code属性我们也来看一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bar.func_code</span><br><span class="line"><span class="keyword">print</span> dir(bar.func_code)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">foo.func_code = bar.func_code</span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出的结果由于比较长，写在了下面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;code object bar at <span class="number">02516</span>C80, file <span class="string">"C:\Users\David-PC\Desktop\Advanced Course on Python 2016\a014.py"</span>, line <span class="number">27</span>&gt;</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__cmp__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>, <span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_lnotab'</span>, <span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，func<em>code是一个code object，它有的属性有很多，基本以co</em>开头，如果有兴趣，可以自己一点点去把他们print出来看，也可以发现很多有趣的东西，这里暂时不进行展开。例子的另外一部分展示了func_code是可以被替换的。</p>
<blockquote>
<p><strong>扩展</strong>：关于code对象，可以阅读<a href="https://late.am/post/2012/03/26/exploring-python-code-objects.html" target="_blank" rel="external">Exploring Python Code Objects</a>，了解怎样通过compile方法来生成code object，以及code类的一些属性。</p>
</blockquote>
<p>关于function中比较重要的几个属性，以表格的形式总结出来。<br>| 属性名称      | 描述   |<br>| ——–      | —–:  |<br>| func_name     | 函数名称 |<br>| func_defaults |   函数的默认值列表   |<br>| func_code     |    函数体的code对象    |<br>| func_globals  |  函数的全局命名空间 |<br>| func_closure  | 函数的cell对象 |<br>看了function的这些属性，对于之前讨论过的hotfix是不是有了更深的了解呢？只需要替换一个函数对象的func_code，func_defaults，func_closure等属性，这个函数的行为就可以被改变了，结合上bound method和unbound method的动态生成的特性，对Python语言的动态性的原理的理解是否有更深入了一步呢？</p>
<h2 id="8-Classes"><a href="#8-Classes" class="headerlink" title="8. Classes"></a>8. Classes</h2><p>关于类，其实有很多可以讨论的内容，从生命周期的角度来看，一个C++类的对象包含如下四个生命周期：</p>
<ol>
<li>内存分配，malloc</li>
<li>调用构造函数初始化对象，A::A()</li>
<li>调用析构函数清理对象，A::~A()</li>
<li>释放内存，free</li>
</ol>
<p>不同的编译器在内存分配或者释放的时候具体使用的函数可能不同，但这四个步骤是都有的，而且在C++中，1和4两个步骤是隐式的，即开发者通常不需要去关心（当然也有可以去操作的方法），它们分别隐含在了构造函数和析构函数当中。<br>对于Python的对象来说，其生命周期包含如下三个部分：</p>
<ol>
<li>内存分配，<code>__new__</code>方法；</li>
<li>调用初始化(initializer)，<code>__init__</code>方法；</li>
<li>调用终结器(finalizer)，<code>__del__</code>方法；</li>
</ol>
<p>对于自定义的类，上述的过程可以通过重载对应的方法来实现对于其过程的控制。可以看到，这里并没有内存释放的过程，也就是说开发者无法主动控制对象所占用过的内存的释放，这一部分是方便开发者不需要进行内存的管理，另外也利于Python语言本身进行对象缓存池的设计与实现。这部分内容在bound method的部分已经看到了缓存池在Python的应用，更多的讨论放在内存管理的部分来进行。</p>
<blockquote>
<p><strong>思考</strong>：Python中如何实现单例模式？是否可以通过重载<code>__new__</code>方法，在每次分配内存的时候返回同一个对象来实现呢？</p>
</blockquote>
<p>答案是否定的，因为Python对于生命周期的控制决定了在<code>__new__</code>方法被调用，内存分配完毕之后会主动调用<code>__init__</code>方法，这样虽然分配的是同一个对象，但是多次<code>__init__</code>方法的调用可能会导致对象的属性被修改，可能会引发意料之外的bug，比如已经被修改过属性又被<code>__init__</code>方法改变等。</p>
<p>说了这些之后，对于Class我们返回Callable的主题，Python中的Class也是一个Callable的对象，调用一个类的结果很简单，就是获得一个类的实例化对象，我们来看一个简单的例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Foo 				<span class="comment"># &lt;class '__main__.Foo'&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo.__call__		<span class="comment"># &lt;method-wrapper '__call__' of type object at 0x029D33E0&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo()				<span class="comment"># &lt;__main__.Foo object at 0x02AAEED0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> func.__call__		<span class="comment"># &lt;method-wrapper '__call__' of function object at 0x029C77F0&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>类Foo是一个class对象，它是可以访问到<code>__call__</code>属性的，它是一个id为0x029D33E0的type对象的’<strong>call</strong>‘方法的method-wrapper，如果打印<code>print id(Foo)</code>的话，你可以发现它的十六进制结果就是0x029D33E0。这容易理解，而对于method-wrapper，我把它理解为一个方法的封装。查了一些资料，但是没有找到官方的精准答案，这里我猜测对象的创建、函数的执行等过程，在Python中可能是一种C的实现，因此在Python层给出的是一个wrapper，可以让他们的行为像一个Python的函数一样。当然这是我的猜测，如果有知道准确答案的朋友欢迎指导。</p>
<blockquote>
<p><strong>思考</strong>：Class作为一个Callable的类型，对于我们开发中有什么好处吗？</p>
</blockquote>
<p>想象一下工厂方法在C++中的实现，通常需要通过一个函数来封装一个对象的创建过程，而在Python中，我们可以把对象类型存储在一个字典或者列表中，通过映射关系，可以直接生成对象。某种程度上说，这也是一种“反射”机制。具体的代码由于比较简单，此处就不列举了。</p>
<blockquote>
<p><strong>总结</strong>：关于Callable的部分已经聊得差不多了，从我们分析的过程看，我们通常使用dir和print在加上一些分析能力就可以看出Python语言设计上的一些原理和思路，一切皆对象的理念被应用的淋漓尽致，而为了实现其动态特性，Python语言做了很多特殊的设计和方法。</p>
</blockquote>
<p>2016年7月10日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/09/pythonadvance4/" class="article-date">
  	<time datetime="2016-07-09T00:42:42.000Z" itemprop="datePublished">2016-07-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/pythonadvance4/">Python进阶(四)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5-Class-method和Static-method"><a href="#5-Class-method和Static-method" class="headerlink" title="5. Class method和Static method"></a>5. Class method和Static method</h2><p>这部分其实不能算Python的进阶内容了，可以说是基础内容。在初学Python的时候我就有过一些疑惑，<code>@classmethod</code>和<code>@staticmethod</code>修饰的函数看上去似乎没有什么区别，都是通过类来调用（当然对象也可以）。本小节内容稍微看一下两者的区别，首先是class method，因为比较简单，直接看代码例子和结果吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">1 37346800</span><br><span class="line">2 37266616</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们把<code>A.foo</code>打印处理，是一个bound method对象，通过对象a来访问也是一样的，我们学着bound method的方式来分析看，m1和m2的id是不同，在理解了第4小节的内容之后这里就比较容易理解了。</p>
<blockquote>
<p><strong>思考</strong>： Class method是绑定了什么东西的bound method呢？</p>
</blockquote>
<p>通过查看bound method对象的im_self属性就可以看到它所绑定的对象了，我们添加一些代码来分析。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> m1.im_self</span><br><span class="line"><span class="keyword">print</span> m2.im_self</span><br><span class="line"></span><br><span class="line">m3 = a.bar</span><br><span class="line"><span class="keyword">print</span> m3.im_self</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;__main__.A object at 0x02440030&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论</strong>： Class Method是绑定了类对象的bound method。</p>
</blockquote>
<p>需要<strong>额外注意</strong>的是，<code>def foo(self):</code>这里对于class method的定义是不好的，具有一定的误导性，这里的self不再是类的实例对象了，而是一个class对象，因此通常写成<code>def foo(cls):</code>或者<code>def foo(klass)</code>更清晰。</p>
<p>Static method是否也是bound method呢？我们直接来看分析代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">37725360</span></span><br><span class="line"><span class="number">2</span> <span class="number">37725360</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>结论</strong>： Static method就是在类的命名空间中的一个普通函数。</p>
</blockquote>
<h2 id="6-Functors和Operators"><a href="#6-Functors和Operators" class="headerlink" title="6. Functors和Operators"></a>6. Functors和Operators</h2><p>在C++中，重写了()操作符的类，它们实例化的对象就是一个functor，在Python中，重写了<code>__call__</code>方法的类的实例对象是一个functor。这里具体的内容就不再详述了，属于Python中比较基本的内容。<br>类似的，关于操作符（Operators），在Python中也是重载一些对应函数，比如+就是重载<code>__add__</code>函数。这里需要说的是一个性能问题，我们来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">5000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(1, 2)'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(1, 2)'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo("1", "2")'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar("1", "2")'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.689781276848</span></span><br><span class="line"><span class="number">1.40617516723</span></span><br><span class="line"><span class="number">0.806692302726</span></span><br><span class="line"><span class="number">1.4724794197</span></span><br></pre></td></tr></table></figure></p>
<p>原理上，+的操作符是调用<code>__add__</code>方法来进行处理，那为什么直接调用<code>__add__</code>方法反而会慢呢？我们使用dis模块来看一下Python代码翻译成Python虚拟机的指令的区别。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">50</span></span><br><span class="line">dis.dis(bar)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> BINARY_ADD          </span><br><span class="line">              <span class="number">7</span> RETURN_VALUE        </span><br><span class="line">--------------------------------------------------</span><br><span class="line">  <span class="number">7</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_ATTR                <span class="number">0</span> (__add__)</span><br><span class="line">              <span class="number">6</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">9</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure></p>
<p>dis模块的dis方法可以打印出传入函数的虚拟机指令，可以看到foo函数使用+，并没有调用<code>__add__</code>方法，而是用了一个BINARY_ADD指令来直接进行加法。这就是它比直接调用<code>__add__</code>方法快的原因。</p>
<blockquote>
<p><strong>总结</strong>：对于Python的内建类型，操作符比直接调用对应的函数要好，Python可能会使用对应的二进制操作进行优化。</p>
<p><strong>思考</strong>: 对于用户自定义的类型呢，效率哪个更高？</p>
</blockquote>
<p>我们来看例子的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		self._value = v</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._value + v._value</span><br><span class="line">		</span><br><span class="line">n1 = Number(<span class="number">1</span>)</span><br><span class="line">n2 = Number(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> n1 + n2</span><br><span class="line"></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(Number(1), Number(2))'</span>, <span class="string">'from __main__ import foo, Number'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(Number(1), Number(2))'</span>, <span class="string">'from __main__ import bar, Number'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1.34897905469</span></span><br><span class="line"><span class="number">1.26909055996</span></span><br></pre></td></tr></table></figure></p>
<p>看上去，直接调用<code>__add__</code>方法反而更快一些，但是差别整体不大。这是因为+操作符会进行优化尝试，需要额外的时间消耗。不过呢，这点时间差别比较小，而且直接使用类似<code>__add__</code>的方法调用对于代码的可读性维护性会带来一定的困扰，因此大部分情况下，<strong>直接使用操作符会更好</strong>。</p>
<p>2016年7月8日晚于杭州网易大厦</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance3/" class="article-date">
  	<time datetime="2016-07-02T20:55:21.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance3/">Python进阶(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4-Bound-Method和Unbound-Method"><a href="#4-Bound-Method和Unbound-Method" class="headerlink" title="4. Bound Method和Unbound Method"></a>4. Bound Method和Unbound Method</h2><blockquote>
<p><strong>声明</strong>: 本系列文章中的所有内容都是基于Python 2.x版本的，原因是网易绝大部分项目都是在用2.x版本，笔者参与过的项目无论端游还是手游都是基于Python 2.7.x版本进行的开发，因此无论经验还是课程适用性，都是在2.x范围内。在Python 3.x中，unbound method的概念已经被取消了。</p>
</blockquote>
<p>上一小节说了，Bound Method和Unbound Method这部分是我参与大雄的课程中最喜欢的一部分，因为它让我窥探到了Python语言动态特性的一角，也加深了我对于平时在用的一种优化方法的认识。这部分会比较长，我们分几个小节来细说。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>先从代码来看，定义一个简单的类A：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure></p>
<p>很简单，我们来打印一些信息来看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> A.foo		<span class="comment"># &lt;unbound method A.foo&gt;</span></span><br><span class="line"><span class="keyword">print</span> a.foo		<span class="comment"># &lt;bound method A.foo of &lt;__main__.A object at 0x023DE070&gt;&gt;</span></span><br><span class="line"><span class="keyword">print</span> A.foo == a.foo <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a, id(a)	<span class="comment">#&lt;__main__.A object at 0x0235E070&gt; 37085296</span></span><br><span class="line"><span class="keyword">print</span> A.foo.im_self	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> a.foo.im_self	<span class="comment"># &lt;__main__.A object at 0x0241E070&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便对比和理解我把输出的结果放在了对应的print之后，首先输出两个<code>A.foo</code>和<code>a.foo</code>，看到了他们分别是两个对象，一个叫做unbound method，一个叫做bound method，很明显他们是两个不同的对象。这跟我从C++角度来理解Python的方法（Method）就有点不同了——通常静态语言中，面向对象的设计，把方法的定义放在类上，对象通过一定的机制（比如虚函数表等）查找到对应的函数地址来进行调用，那按这样推理，A.foo和a.foo应该是一个东西才对。事实证明Python语言不是这样的。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance3/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance2/" class="article-date">
  	<time datetime="2016-07-02T20:54:20.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance2/">Python进阶(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一部分是关于Python的Callable。在Stackoverflow上有一个专门的问题叫做<a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python">“What is a “callable” in Python”</a>，高票回答中说：</p>
<blockquote>
<p>A callable is anything that can be called.</p>
</blockquote>
<p>这个回答很抽象，大雄从更具体的角度来阐述Callable这个概念——在Python中哪些是callable的？</p>
<ul>
<li><strong>function</strong></li>
<li><strong>closure</strong></li>
<li><strong>bound method</strong></li>
<li><strong>unbound method</strong></li>
<li><strong>class method</strong></li>
<li><strong>static method</strong></li>
<li><strong>functor</strong></li>
<li><strong>operator</strong></li>
<li><strong>class</strong></li>
</ul>
<p>先说答案，很明显，列出的这些都是callable的。这些概念中的大部分我在工作中都有使用，包括比如closure的坑也帮助新同学调试bug的时候看到新入职的同学自己踩到过，但是对于<strong>bound method</strong>和<strong>unbound method</strong>这些概念还不是很清晰。我们也一个个来看。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance2/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/30/pythonadvance1/" class="article-date">
  	<time datetime="2016-06-30T15:01:26.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/pythonadvance1/">Python进阶(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周听了三节Python进阶课程，有十几年的老程序给你讲课传授一门语言的进阶知识，也许这是在大公司才能享受到的福利。虽然接触使用Python也有三四年时间了，但是从课程中还是学习到不少东西，掌握了新技巧的用法，明白了老知识背后的原因。<br>下载了课件，做了笔记，但我还是希望用讲述的方式把它们表现出来，为未来的自己，也给需要的读者。整体以大雄的课程为蓝本，结合我在开发中的一些自己的体会和想法。</p>
<h2 id="1-写操作对于命名空间的影响"><a href="#1-写操作对于命名空间的影响" class="headerlink" title="1. 写操作对于命名空间的影响"></a>1. 写操作对于命名空间的影响</h2><p>首先来看这样一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(processed)</span>:</span></span><br><span class="line">	value = math.pi</span><br><span class="line"></span><br><span class="line">	<span class="comment"># The other programmer add logic here.</span></span><br><span class="line">	<span class="keyword">if</span> processed:</span><br><span class="line">		<span class="keyword">import</span> math</span><br><span class="line">		value = math.sin(value)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">print</span> value</span><br><span class="line">	</span><br><span class="line">foo(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>思考</strong>：你觉得这段代码有没有什么问题，它的运行结果是什么？</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/30/pythonadvance1/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/29/hello-world/" class="article-date">
  	<time datetime="2016-06-28T17:01:43.000Z" itemprop="datePublished">2016-06-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/29/hello-world/">讲述者源始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从大学时代开始，尝试各种形形色色的博客，从网易博客到新浪博客，再到Lofter、简书，甚至写在纸质本子上的手账，断断续续记录，断断续续写作。有些尘封在过往的时光中，布满灰尘，连自己都不再记得内容和样子；有些依然偶尔去填一些文字或者记上几句感慨，不关心过往路人的喜好或者评价。</p>
<p>零散的过去分布在网落的各个角落，每一个都是曾经的开始，现在却已无法把它们找回。但坚持记录了两个多月的手账让我看到了一些不同的东西——有时一天几十个字，有时写满一页，都不过是些当天的总结和思考，或者一些抱怨的话，但沉淀下来，就是逝去的生活。</p>
<p>手账记录给自己，但有些故事想讲给旁人听。于是有了它——<a href="http://www.inarrater.com" target="_blank" rel="external">http://inarrater.com</a>，讲述者。基于Hexo和github搭建的静态独立博客，域名inarrater，我，讲述者。</p>
<p>讲述和记录的不同，在于讲述在乎倾听者，而记录大多只为自己。所以用讲述者命名博客，希望自己放在这里的文字不只是为了取悦自己。它当然可能包含零散的小说，技术的总结，读书的感悟，人生的思考，无论何种形式，务求言之有物。</p>
<p>搭建讲述者，花费大约三个晚上的时间，遇到一些技术问题，包括Hexo的框架，主题的选择，域名的购买，DNS的设置等等。博客还有些简陋，但内容的重要程度大于形式，为了搭建它已经推迟了很多计划，所以可能不会再在这个上面花费太多时间和精力，望见谅。</p>
<p>2016年6月29日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 董夕
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>