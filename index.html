<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Narrater</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Narrater">
<meta property="og:url" content="http://inarrater.com/index.html">
<meta property="og:site_name" content="Narrater">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Narrater">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Narrater" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">董夕</a></h1>
		</hgroup>

		
		<p class="header-subtitle">讲述，而非记录</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Lua/" style="font-size: 10px;">Lua</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/开发/" style="font-size: 20px;">开发</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">程序员，对故事有爱，想要有趣的人生。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">董夕</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">董夕</h1>
			</hgroup>
			
			<p class="header-subtitle">讲述，而非记录</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-unitydev3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/25/unitydev3/" class="article-date">
  	<time datetime="2016-12-25T14:59:07.000Z" itemprop="datePublished">2016-12-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/25/unitydev3/">Unity手游开发札记——从零开始搭建手游开发的工具集</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从8月中旬到现在12月底，四个多月的时间，经历团队组建、引擎熟悉、基础工作流搭建、核心Demo开发以及一些技术预研的工作，这其中的每一项拿出来都可以写出一篇文章。之前已经聊过一些Unity和Lua相关的技术，今天就主要聊一聊不那么技术的部分——对于一个从零开始组建的小团队，游戏开发的一些基础的工作流程和协作工具，希望可以帮助后来人节省部分时间，也抛砖引玉，想了解下其他团队中有什么更好的解决方案~</p>
<h2 id="1-为什么需要"><a href="#1-为什么需要" class="headerlink" title="1. 为什么需要"></a>1. 为什么需要</h2><p>商业游戏的开发是一个大工程，需要参与的职位很多——策划、程序、美术、QA、营销、外包等等，每一个职位的人也不少，比如策划团队可能会有6-7人，程序团队可能会在10人以上，还会区分客户端与服务端。要想让游戏开发的工作可以更好更快地推进，确保每个职位之间和内部的协作都是顺畅的，需要工作流的精确定义和强大工具的支持。</p>
<p>在游戏开发中，程序的职责不仅仅是实现游戏玩法逻辑，构建合理的工作流程和开发强力的工具集也是工作的一部分。这一部分内容可能无法体现在最后发布的游戏中，但是在保证项目按时完成，提升整个团队的工作效率方面却具有非常重大的意义。</p>
<p>在大公司中，这部分内容会由IT、运维等其他部门的同事提供，但是在一家小公司，一切只能自己动手。作为程序组的负责人，特别是最初只有我一个程序的情况下，这份看上去<em>只是进行一些工具调研，然后部署</em>的工作就毫无疑问地落在了我的身上。实话实说，相对于实现一个有意思的玩法，这个过程的确有些枯燥无趣，但回头来看，这些工作让整个团队可以顺利地推进工作，沉淀知识，反思问题，也是一种成就感。</p>
<h2 id="2-包含哪些内容"><a href="#2-包含哪些内容" class="headerlink" title="2. 包含哪些内容"></a>2. 包含哪些内容</h2><p>这里涉及到的绝大部分工具都是不自己开发的，而是对于世面上已有的工具的试用和选择。本文也不进行深入的技术探究，只从自己团队需求的角度出发，记录这些工具的选择过程和决策原因。涉及的部分包括沟通工具、知识分享、版本管理、项目协作与管理、自动化构建工具、编辑器和部分程序开发工具这几个方面。</p>
<h2 id="3-沟通工具"><a href="#3-沟通工具" class="headerlink" title="3. 沟通工具"></a>3. 沟通工具</h2><p>在团队组建的最初，我们只有一个微信群来进行沟通。在搬进新的工作地点之后，公司正式成立，就需要确定对内和对外使用的沟通工具。这部分内容看上去非常简单，但也有很多值得思考的内容。</p>
<h3 id="3-1-邮件服务"><a href="#3-1-邮件服务" class="headerlink" title="3.1 邮件服务"></a>3.1 邮件服务</h3><p>邮件服务作为一个最为正式的沟通工具，无论是对内还是对外，都需要可以正常使用。可以进行的选择是自己搭建一个邮件服务器还是使用比如腾讯或者阿里这样大公司提供的企业级邮箱。在经过一些调研、对比和讨论之后，出于对邮件内容安全性的考虑，我们选择了自己搭建的方式。<br>使用<strong>MDaemon</strong>作为邮件服务器，申请了公司的域名，购买了阿里云的主机，搭建过程交给了一个朋友帮忙（所以不要问我是不是破解版，我不会回答的。。。），目前的工作方式是我自己远程上去手动维护邮件账户和列表。（这有点蛋疼，但不频繁还可以忍受…）<br>客户端我们没有强制规定，但大部分使用了网易的闪电邮，这完全是习惯使然，其中的日历和会议邀请功能还是很实用的。</p>
<h3 id="3-2-即时通讯工具"><a href="#3-2-即时通讯工具" class="headerlink" title="3.2 即时通讯工具"></a>3.2 即时通讯工具</h3><p>每个团队都需要IM工具，在网易的时候使用的是POPO，但是作为一个对外好久没有更新的工具，而且是“老东家”的产品，有点怕。我们调研了Slack、钉钉、微信企业版，考虑了QQ，最终选择了钉钉。我个人很喜欢Slack这一类型的IM工具——使用频道代替群的概念，信息永久保存、可以修改搜索消息，这些设计减少了水群的存在，也让沟通的人说话更加谨慎高效。</p>
<p>但是，Slack没有中文版本，询问了一下开发者，貌似近期也没有推出的计划，而国内几个小团队做的相似版本不太敢去用，怕哪天倒闭了聊天内容都没办法导出来。相比之下，虽然钉钉有很多我个人不喜欢的地方——譬如“钉一下”的概念是为老板服务的——我们还是无奈选择了它，有如下几个原因：</p>
<ol>
<li>带有简单的OA，比如部门管理、签到、审批，这些是我们初期需要但又不想花太多时间去开发新的内容；</li>
<li>有比较完备的桌面版和移动版；</li>
<li>使用方式还是比较常规的方式，适合策划和美术上手；</li>
<li>有Open API提供，可以进行一些工具的开发；</li>
<li>阿里“爸爸”怎么说也是家大公司，倒掉的概率比较小。。。对于我们这种小团队的信息也懒得偷看（迫害妄想症）。。。</li>
</ol>
<p>当然用了这几个月也有很多槽点想吐：</p>
<ol>
<li>完全没办法图文混排，美术吐槽这点吐槽了好久；</li>
<li>传输文件不是点对点的方式，而是上传然后再下载，也无法传输文件夹，我们现在局域网传输都不用它了，嫌慢又怕外泄；</li>
<li>出于安全的考虑，Open API不开放获取聊天信息的接口，导致我们现在一些想做的便捷功能没办法做；</li>
<li>我只把它当做一个IM工具，不想钉别人，也不想被别人钉……（纯吐槽）</li>
</ol>
<p>总之，小而精的团队，可以尝试下Slack~~</p>
<h3 id="3-3-现场沟通"><a href="#3-3-现场沟通" class="headerlink" title="3.3 现场沟通"></a>3.3 现场沟通</h3><p>对于小团队来说，吼一嗓子，或者跑到位置上去聊，可能是最为快速高效的工作方式了。这不需要任何工具，只是有时候需要提醒注意讨论对于其他人工作效率的影响，比较长或者涉及人比较多的讨论还是建议去会议室进行。但最好进去之前明确讨论主题，注意讨论时间，否则很容易错过饭点。。。（流泪）</p>
<h2 id="4-知识共享"><a href="#4-知识共享" class="headerlink" title="4 知识共享"></a>4 知识共享</h2><p>团队开发需要知识共享，一些规范也需要让别人可以方便地查找，对于后进入团队的人，也可以尽快熟悉规范，避免一些坑重复去踩。因此我们需要一些知识和文件共享的方式。</p>
<h3 id="4-1-文件共享"><a href="#4-1-文件共享" class="headerlink" title="4.1 文件共享"></a>4.1 文件共享</h3><p>文件共享分为两种，不需要版本控制的我们使用了FTP的方式，购买了一台windows server的服务器放置在了内网，然后直接使用了系统自带的FPT服务，用于文件共享和一些内网的文件传输中转，简单粗暴。<br>需要版本控制的文件，比如策划文档，我们使用了SVN进行管理。</p>
<h3 id="4-2-文档共享"><a href="#4-2-文档共享" class="headerlink" title="4.2 文档共享"></a>4.2 文档共享</h3><p>基本上是出于个人习惯的考虑，文档共享方面推荐团队使用了<a href="https://www.yinxiang.com/" target="_blank" rel="external">印象笔记</a>。一开始团队中有人吐槽它没有文件夹管理太难用，其实我觉得Tag的方式比文件夹更加方便合理。当然也有一些不方便的地方：</p>
<ol>
<li>无法支持两个人同时编辑一份文档，甚至一个人看的时候光标只要在文档内就会把文档锁定别人无法修改。当时考虑了一下<a href="https://shimo.im/" target="_blank" rel="external">石墨文档</a>，但是没有推广去用，需要的朋友可以去看下。</li>
<li>对于Markdown的支持不够好，排版太难看。。。叹气。<a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a>虽然可以用，收费不说，还不能在印象笔记中修改，怎么共同编辑，摔。</li>
<li>美术不乐意用，嫌弃说都是文字不够直观……这个我也没办法，手动摊手。</li>
</ol>
<p>知识共享和记录是一件非常重要的事情，前两天就遇到部署Jenkins的时候没有做记录，然后重启机器遇到问题忘记怎么弄又捣鼓半天的事情。年纪大了，事情多了，脑袋不好使了，烂笔头更重要了。更何况，很多东西是规范性的，需要其他职位的人遵守，口头的约定总是会忘记或者记不清楚，落实到文字上才更有约束力。</p>
<h2 id="5-版本管理"><a href="#5-版本管理" class="headerlink" title="5 版本管理"></a>5 版本管理</h2><p>前面提到了，策划文档使用了SVN管理，游戏工程也是选择了SVN，原因是团队大部分成员习惯了SVN的使用。如果只有程序团队使用，可能就去推行Git了，但是想想要给美术和策划培训Git，还有解释本地版本和服务器版本的概念就头疼。在刚进入网易的时候有一段时间是跟着美术处理各种svn冲突，clean up无效等问题，深深体会到svn和git这种按照程序员理性思维建立的工具，感性的美术需要花挺多精力去理解。</p>
<h3 id="5-1-外链问题"><a href="#5-1-外链问题" class="headerlink" title="5.1 外链问题"></a>5.1 外链问题</h3><p>在工程中，避免不了的是有些目录需要同时出现在多个地方，比如客户端与服务端可能会共用一份数据文件，当数据修改的时候，在多处进行修改是不合适的做法，维护起来很麻烦。于是版本管理软件提供了外链的功能，比如svn的externals。但是外链有一个很严重的问题是当你需要建立分支的时候，如果不做任何修改，外链还会是指认到原始trunk上的路径，当外链很多的时候，就需要针对每个外链单独建立分支，然后修改整个分支中所有外链的路径到正确的分支位置去。在项目后期，需要编写一个单独的脚本来进行分支的创建，而不是一条简单的cp指令就可以了。与外链相对应的是所谓的“内链”，即路径不再是一个以https或者svn开头的全地址路径，而是一个类似<code>../../../CommonData</code>这样的相对路径。这样，只要保证分支是在根目录创建的，内链就是分支内部的路径，不需要做任何额外的修改。当然，内链无法跨svn repository运作，如果是另外一个svn repository的内容，只能使用外链的方式。<br>SVN的这部分构建和设计工作最好在项目初期做好规划，否则后期进行分支维护的时候会比较麻烦，容易出错。</p>
<h3 id="5-2-工具使用"><a href="#5-2-工具使用" class="headerlink" title="5.2 工具使用"></a>5.2 工具使用</h3><p>SVN服务使用了最为简单的VisualSVN Server，带有gui，方便易用，目前比较恶心一点的是为别人创建账号的时候密码输入只能在界面上进行，暂时没时间调研更好的工具来自己创建账号。<strong>权限的分配完全按照Group进行，从不单独针对某一个账号进行权限分配</strong>，这点是在网易的时候维护SVN权限时老大强调的一点，方便，不容易出错。虽然是小团队，但是SVN的权限管理还是要做好，否则代码泄露出去隐患还是很大的。</p>
<p>SVN服务端的Hook目前只加了两个：</p>
<ol>
<li>不允许提交过短的log，强制防止有人偷懒不写log；</li>
<li>允许log被提交者自己编辑。</li>
</ol>
<p>客户端基本推广的是小乌龟，Mac和Linux就使用命令行。美术同学有人喜欢装一个中文语言包，就按照各自的喜好去用。这里有几个小Tips提供给不太熟悉小乌龟的人：</p>
<ol>
<li>按住Shift点击右键，弹出的svn菜单里会多一些比如“删除不再版本控制下的文件”这样的快速选项；</li>
<li>在Settings中，Main Context Menu中可以添加常用的菜单选项，比如revert、Show Log，这样就不需要进入SVN的二级菜单了；</li>
<li>如果在update的时候，有更新的文件被比如3DS Max、Photoshop等软件打开着的时候，可能会出现被锁死的情况，这时候提示你要进行Clean up操作，在关闭了相应软件之后，如果Clean up仍然失败，可以尝试使用如下的代码来解决。如果仍然不行，可以只删除掉.svn文件，然后重新check out，这样既可以保留已有的修改，又可以避免下载所有的文件，加快速度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite3.exe .svn/wc.db &quot;select * from work_queue&quot;</span><br><span class="line">sqlite3 .svn/wc.db &quot;delete from work_queue&quot;</span><br><span class="line">ECHO &quot;DONE!&quot;</span><br><span class="line">PAUSE</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-3-美术外包资源管理"><a href="#5-3-美术外包资源管理" class="headerlink" title="5.3 美术外包资源管理"></a>5.3 美术外包资源管理</h3><p>除了游戏工程之外，美术外包或者内部制作的Max等资源也需要进行一定的版本管理。本质上说，使用svn对这部分资源进行管理并不合适，因为这些资源大都是二进制而非文本的，svn这种代码版本管理软件并不非常合适，更好的选择是NXN和Preforce这样的——有图形化的树状结构界面，不需要完整下载到本地，修改之前必须获取锁——这些这对于美术来说是更加直观、容易理解的方式。<br>但是，NXN收费很贵，Preforce也只允许20人以下的团队免费使用。花费了一些时间去做调研，但是目前我们出于统一和成本的角度考虑，依然使用SVN来对这部分的美术资源进行管理，后续可能会进行一些改进。</p>
<blockquote>
<p>在一个团队中，推广一个工具的使用需要不少的人力成本，尤其是美术和程序是两种不太相同的思维方式，而且很多美术对于工具使用都是一种机械记忆而非理解原理的方式，因此这也限制了一些可能更好的工具的应用。</p>
</blockquote>
<h2 id="6-项目管理与协作"><a href="#6-项目管理与协作" class="headerlink" title="6. 项目管理与协作"></a>6. 项目管理与协作</h2><p>项目管理这一部分也是花费了较多时间的，调研和试用了一系列的工具，稍微整理一下：</p>
<ol>
<li><strong>Project和Excel</strong>，这是最为传统的项目管理软件了，简单来说基于甘特图，适合项目经历做排期和监控项目进度，但是对于团队中各个职位的同事协作帮助并不大。</li>
<li><strong>Redmine</strong>，在网易的时候也是使用Redmine进行项目管理的，后来网易公司也自己开发和扩展了“易协作”这样的平台。这应该是最为老牌和经典的项目协作软件了，免费开源，也有比较丰富的插件提供。</li>
<li><strong>偏向敏捷开发的协作平台</strong>，比如<a href="https://www.teambition.com/" target="_blank" rel="external">teambition</a>、<a href="www.tower.im">Tower</a>、<a href="www.worklite.com">Worklite</a>等等，试用了几个，感觉大同小异，和Redmine的区别在于更加偏向于小团队敏捷开发，一些跨职位的流程功能提供不是非常全面，比如有些就没有提供从策划提单、程序做单、QA测单的流程性的东西。</li>
</ol>
<p>目前我们采用了内网Redmine+worklite的方式。出于搭建方便，节省时间的考虑，从淘宝购买了一套组织好插件的所谓“一键部署”的Redmine版本，自己做了两个简单的调整：</p>
<ol>
<li>我的工作台看板增加若干列，提供更多信息；</li>
<li>ticket可以进行主题和描述的编辑功能。<br>部署过程还算顺利，除了遇到了端口和VisualSVN Server使用的端口冲突之外，没遇到太多问题，后面修改这两个调整花费了一些时间，对于Ruby和Web开发都不是很熟悉，一点点通过代码搜索来寻找修改的地方，然后不断测试修改才搞定。<br>Worklite我们用在对外美术外包的一些工作管理和面试流程管理上，因为外网方便访问，所以这么来做。我个人是很想推进一些敏捷协作平台的使用的，无论从理念上还是从美感上，可能都比Redmine要舒服一些，但是最终在试用之后没有这么来做的原因有如下几个：</li>
<li>数据安全性的考虑，项目的一些内容，比如玩法设计可能会在任务单中有体现，这些是想保密的，放在外网服务器还是有些担心；</li>
<li>做平台的小公司倒掉了，我们怎么办？迁移的成本很大。</li>
<li>比如前文提到过的从策划提单、程序做单、QA测单的工作流程，很多敏捷工具不能很好地定义和推进；</li>
<li>有一些硬性的功能修改需求，使用Redmine花费一些时间还有可能实现，使用别人的平台，可能只能去提建议；</li>
<li>在试用的时候，遇到过外网访问困难的情况，比如刷新慢，上传文件比较慢等等问题，还是内网效率高速度快；</li>
</ol>
<blockquote>
<p>对于工具的选择，往往有各方面的限制，其实不完全是决定着自己的喜好可以左右的……</p>
</blockquote>
<h2 id="7-自动化构建工具"><a href="#7-自动化构建工具" class="headerlink" title="7. 自动化构建工具"></a>7. 自动化构建工具</h2><p>网易内部有一套很有趣的网易POPO机器人，来辅助比如导表、打包这样的自动化构建过程，减少程序员的工作量。会申请一个特定的机器人账号，把它加入到一些工作群，只需要在这些群里输入比如“Android打包”，它就会构建已经建立好的自动化脚本进行打包，并把结果输出在群里，比如失败的错误信息，成功之后的下载链接等等。<br>这套东西非常方便，最初选择钉钉的时候看到有Open API就想去构建一下这套自动化的流程，后来经过测试和向官方询问发现无法通过接口获取群的聊天信息，其实后来也想通过网络抓包、钉钉软件破解等方式来做，但是太过麻烦，而且维护起来比较费时，所以选择了使用Jenkins+钉钉的方式。<br>Jenkins本身就是自动化持续构建的工具，钉钉只是用来反馈一些信息给策划、美术这些不习惯使用Jenkins的同事，比如打包结果，导表的错误信息等。这里提供一个简单的通过钉钉发送消息的Python脚本，需要的可以拿去用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> HTTPUtils <span class="keyword">import</span> http_get</span><br><span class="line"><span class="keyword">from</span> HTTPUtils <span class="keyword">import</span> http_post</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Token每隔两个小时过期一次，再次获取刷新时间间隔。"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(TokenManager, self).__init__()</span><br><span class="line">        self._token = <span class="keyword">None</span></span><br><span class="line">        self._update_time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (self._token <span class="keyword">and</span> (time.time() - self._update_time &lt; <span class="number">1000</span>)):</span><br><span class="line">            self._token = get_access_token()</span><br><span class="line">            self._update_time = time.time()</span><br><span class="line">        <span class="keyword">return</span> self._token</span><br><span class="line">        </span><br><span class="line">token_mgr_instance = TokenManager()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_access_token</span><span class="params">()</span>:</span></span><br><span class="line">    access_token = <span class="keyword">None</span></span><br><span class="line">    ret, msg = http_get(<span class="string">"https://oapi.dingtalk.com/gettoken?corpid=%s&amp;corpsecret=%s"</span>%(Config.CORP_ID, Config.CORP_SECRET))</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        access_token = msg[<span class="string">"access_token"</span>]</span><br><span class="line">    <span class="keyword">return</span> access_token</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(msg, chat_id = Config.ROBOT_CHAT_ID)</span>:</span></span><br><span class="line">    access_token = token_mgr_instance.get_token()</span><br><span class="line">    data = &#123;<span class="string">"chatid"</span> : chat_id, </span><br><span class="line">            <span class="string">"sender"</span> : Config.ROBOT_ID,</span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"text"</span>:&#123;</span><br><span class="line">                <span class="string">"content"</span> : msg</span><br><span class="line">            &#125;&#125;</span><br><span class="line">    ret, msg = http_post(<span class="string">"https://oapi.dingtalk.com/chat/send?access_token=%s"</span>%access_token, data)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p>
<p><code>http_get</code>和<code>http_post</code>两个方法使用了Requests，基本定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_get</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">return</span> handle_result(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_post</span><span class="params">(url, data)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">        <span class="string">"Accept-Charset"</span>: <span class="string">"utf-8"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(url, headers=headers, data=json.dumps(data), timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">return</span> handle_result(result)</span><br></pre></td></tr></table></figure>
<p>最初的时候使用urllib2，但是在mac系统上遇到了SSL错误的问题，研究半天最后还是使用了Requests库来做。Jenkins的搭建也是花费了一些时间和精力，包括在Mac机器上的权限问题，编码问题，SVN权限问题等等，可惜的是当时没有做完整详细的记录，一些坑没有办法完全记录下来，但是遇到了之后通过Google都可以找到解决方案。</p>
<blockquote>
<p>通过这一套方案，加上一些基于Python脚本构建的自动化打包、导表等流程，就可以让一些原本需要程序来做的工作编程策划/美术驱动机器人来完成，没有错误的情况下无需程序参与。</p>
</blockquote>
<h2 id="8-编辑器"><a href="#8-编辑器" class="headerlink" title="8. 编辑器"></a>8. 编辑器</h2><p>游戏开发的最理性情况，是程序编写玩法框架，策划来填充游戏内容，比如UE4的蓝图功能、Unity的PlayMaker插件，就是一种对于程序工作的释放。但是在一个大型商业游戏的开发中，引擎原生提供的编辑工具还是无法为策划、美术和UI提供完整的游戏内容实现工具，需要程序来实现一些与游戏玩法相关的编辑器或者代码功能，比如技能编辑、战场编辑器等等。</p>
<p>网易早期，加上现在了解到的一些创业小团队，是以Excel表为核心提供策划编辑的功能。Excel的强大功能和灵活的编辑方式的确为策划提供了很多便利，但是还有一些小问题：</p>
<ol>
<li>比较难做到所见即所得，即对于有些东西的编辑不够直观，比如场景中的位置等；</li>
<li>一些多维的数据需要进行拆分到多张表里的方式实现，设计和填写上会有些困难；</li>
<li>比较难限制策划填写一些数据的正确性，比如一个外键值，策划填写时需要去其他表中查询这个key值是否存在，编辑器就可以提供下拉列表这样的方式来做。（Excel使用比较麻烦的方式也可以做到，或者在导表程序的后处理中检查。）</li>
</ol>
<p>对于这样的数据，我们采用编辑器的方式来实现，之前项目使用了一套元数据的编辑器框架，不需要维护编辑器的人修改界面，只需要简单增加或者修改一些元数据就可以了。Unity引擎本身的编辑器就是类似这样的实现思路，因此我们无需做额外的太多工作。</p>
<blockquote>
<p>编辑器的开发需要消耗程序不少的工作量，因此有时候在进度紧张人力不够的情况下，需要评估编辑器能够产出的价值。当编辑器真正能够让使用者的工作效率得到的提升远大于程序付出的时候，编辑器的意义才能够展现出来。</p>
</blockquote>
<h2 id="9-程序开发工具"><a href="#9-程序开发工具" class="headerlink" title="9. 程序开发工具"></a>9. 程序开发工具</h2><p>程序开发工具可以说的有很多，这里分为Unity和Lua脚本两部分进行简单的描述。</p>
<h3 id="9-1-Unity引擎部分"><a href="#9-1-Unity引擎部分" class="headerlink" title="9.1 Unity引擎部分"></a>9.1 Unity引擎部分</h3><p>选择了Unity作为游戏开发的引擎，为了方便热更使用了Lua作为游戏逻辑开发的脚本语言。Unity引擎对于游戏调试的支持还是很好的，我们在开发便利性方面只引入了两个增强型的工具：</p>
<ol>
<li>Unity Editor内的SVN集成插件：<a href="https://www.assetstore.unity3d.com/en/#!/content/49128" target="_blank" rel="external">Svn Tools Lite</a></li>
<li>控制台Log查看支持搜索等功能的扩展：<a href="https://www.assetstore.unity3d.com/en/#!/content/42381" target="_blank" rel="external">Console Enhanced Free</a></li>
</ol>
<h3 id="9-2-Lua部分"><a href="#9-2-Lua部分" class="headerlink" title="9.2 Lua部分"></a>9.2 Lua部分</h3><p>Lua语言方面，我们使用了<a href="https://github.com/lipp/tango" target="_blank" rel="external">Tango</a>作为<strong>跨Lua虚拟机通讯</strong>的解决方案。在游戏脚本开发中，支持断点调试通常比较困难，或者在联网情况下并不非常好用，比如有可能一断点就网络就断掉了，因此类似于Telnet的方案，可以在另外一个Lua虚拟机中直接连接游戏进程中的Lua虚拟机，进行一些属性查看、方法调用，也是一种非常实用的方法，甚至可以支持远程连接移动设备进行调试。</p>
<p>这种多虚拟机的整合方案在网易内部应用得非常广泛，因为我参与的大部分项目都使用了Python语言，因此使用<a href="https://rpyc.readthedocs.io/en/latest/" target="_blank" rel="external">RPyC</a>作为解决方案，为游戏引擎外运行的编辑器开发提供了非常多的便利，与测试用的服务器相连接，也可以通过编辑器/控制台直接更新服务器内存数据。在手游项目中，也大量的使用于设备上的测试。可惜的是目前使用Lua语言，Tango虽然也提供了类似的功能，但是相比如RPyC来说完备性和易用性差很多，而且它是一个5年没有维护的项目了。。。好在基本的功能还是可以使用的，因此也就不再挑剔什么了。</p>
<p>在游戏逻辑的开发中，可以利用Lua脚本语言的动态特性，提供运行时Reload的功能，在不重启游戏的情况下，修改游戏逻辑之后直接一键Reload游戏代码，然后查看修改结果。这可以非常大地提升游戏开发效率，当然对于添加函数或者修改数据结构这样的修改可能会存在一些问题，适用性有一定的限制。</p>
<p>Lua的断点调试方式我们目前还没有走通，ToLua#的中提供了一套基于<a href="https://studio.zerobrane.com/" target="_blank" rel="external">zerobrane</a>的调试方法，但是我们试用还存在一些问题，断点只能停在main函数入口的地方，其他位置无法断点，还需要一些时间踩坑。</p>
<p>Lua这部分可以聊的有很多，语言特性、面向对象的结构等等，有时间计划拿出单独的一篇博客来讲，这里就只提供上面的几个工具的实现思路，有兴趣的可以留言详细聊。</p>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>洋洋洒洒写了这么多，其实有技术含量的东西不多，但这些零零碎碎的工作，却又是从零开始组织一个手游开发公司必不可少的过程。一个程序的负责人必须利用有限的时间和人力，使用尽量少的资源搭建起让所有职位都可以正常运转与合作的工作流程与工具集合，而且尽量让这个流程更高效。</p>
<p>从大公司的“温室”里“逃”出来，想做些不一样的事情，但初始要做的，却是这些在大公司不屑于去做的事情。这虽然有点讽刺的以为，但这个过程，也是学习和反思的过程——从之前的工作流程中提取好用高效的部分，反思哪些流程是可以改变和改进的。惭愧的是，现在搭建和使用的这些工具，大多还是“网易 like”的模式，不过已经看清了那些好处和坏处，等以后有人力和时间的时候，可以进行大刀阔斧的改进，这些是在大公司不太会去思考和改变的。</p>
<p>2016年12月25日夜 于杭州家中<br>PS：圣诞夜，老婆去马来西亚学习潜水了，我自己一个人在家写这篇总结，想想还有点凄凉。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具/">工具</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unitydev2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/27/unitydev2/" class="article-date">
  	<time datetime="2016-11-27T09:52:53.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/27/unitydev2/">MMO游戏优化经验分享沙龙总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天去上海参加了UWA公司的张鑫和张强进行了一场关于MMO游戏开发和性能优化的沙龙，活动链接为：<a href="http://blog.uwa4d.com/archives/Openday1126.html" target="_blank" rel="external">UWA优化日上海站|传统MMO手游性能该如何突围？</a>。虽然第二场场景分块加载部分的内容没有预期中对目前的项目那么有帮助，再加上最后因为赶火车没有听完Q&amp;A的环节就离开了（然而还是没有赶上火车，此中悲苦就不提了。。。），有些疑问没有提出来讨论，略有遗憾，但对于我这样一个刚刚接触Unity的新兵来说，收获颇丰。因此这里做一个简单的记录和整理，只包含现场讨论我印象比较深的一些点，与讲座内容的顺序没有直接对应关系，更加详细、条目性的内容可以参考官方放出的正式文档。</p>
<h2 id="0-关于UWA"><a href="#0-关于UWA" class="headerlink" title="0. 关于UWA"></a>0. 关于UWA</h2><p>张鑫博士介绍了UWA成立这一年多时间内做过的事情，我还是比较赞赏有组织在做这件事情的，可以说是Unity引擎和用户之间除了官网文档和官网技术支持之外的一座桥梁。虽然说他们目前的存在价值和盈利方式依赖于Unity引擎和这样一个生态圈，但是对于程序员来说，它们比单纯的引擎部门接近游戏产品，和做产品的比又更纯粹，没那么功利，介于两者之间。如果有合适的机会我还是挺想做一做这样的事情的，哈哈~</p>
<p>目前来说，能有这样的一群人帮忙提供一些技术上的分享，一些坑可以拿出专门的时间和精力去踩和分析，对于没有引擎组的小团队来说是非常好的事情。</p>
<p>张鑫博士提到他们提供热更新方案，会后单独问了一下还是只支持Android的版本，Lua方案的热更新还没有人力去做。希望后面可以有人力来做一些这方面的踩坑和性能优化工作……</p>
<p>##1. UI系统中的Mesh重建</p>
<p>在UI系统的优化中，着重提到了Mesh重建的过程，这通常是一个消耗最大的部分，因此也是优化需要关注的重点。在NGUI中，这一过程发生在Panel的LateUpdate函数中——由于NGUI是插件的形式，因此这一过程是在C#中的，每次需要改变渲染网格时都会销毁内存中的mesh进行重建操作。而对于UGUI来说，这一过程是在Cavas的BuildBatch中进行的，已经被封装成了Native的实现，因此在UGUI中这部分<strong>没有额外的堆内存分配</strong>，这也是UWA官网把UGUI在运行时分配的堆内存大小标准定义为小于2M，而NGUI的建议标准是小于20M的核心原因。</p>
<p>那么，如何降低UI系统中Mesh重建的次数呢？主要从以下两点出发：</p>
<blockquote>
<ul>
<li>当ui发生改变，比如有组件的添加、删除、遮挡关系改变等事情发生的时候会需要重建Mesh，<strong>而当ui的transform发生改变的时候，如果不影响原本的遮挡关系，是不会导致Mesh重建的过程的</strong>。</li>
<li>UGUI中Mesh的重建的<strong>基本单位是Canvas</strong>。</li>
</ul>
</blockquote>
<p>上述两点分别对应两个优化思路：</p>
<blockquote>
<ul>
<li>尽量减少Mesh重建发生的次数；</li>
<li>当一定需要Mesh重建的时候，尽量减少Mesh重建影响的范围；</li>
</ul>
</blockquote>
<p>针对第一点，除了不要进行不必要的ui修改操作之外，<strong>对于需要频繁切换的复杂界面</strong>，张鑫博士给出的建议是：</p>
<blockquote>
<p>“不要使用实例化/销毁操作来实现界面的切换，会有很大的额外开销，对于active/deactive操作来说也会有mesh重建的过程。推荐通过将其坐标移出视窗之外，或者通过Camera的Layer机制来隐藏界面这两种方式具有最好的性能效果。”</p>
</blockquote>
<p>一个使用案例是背包界面，有大量的item，创建过程消耗也会很大，如果内存允许的话，使用上述方法会有最小的性能开销。</p>
<p>而尽量减少Mesh重建影响的范围则对应一个基本原则——<code>动静分离</code>，即把不需要动态改变和需要频繁地动态改变的组件分离出来。按照上述的第二点，可以使用canvas进行<code>动静分离</code>。就是说比如某个组件下面挂的东西是一个会动态变化的部分，那就把它独立成一个canvas。比如仍然以背包界面为例，滑动内容会导致界面的变化，在滑动过程中每帧都会有Mesh的重建操作。把滚动的部分做成单独的Canvas，这样背景图片和标题等部分就不会被每帧重建了。</p>
<p>这里需要着重注意的是一些会频繁改变的动态部分，比较容易遗忘，比如聊天中的<strong>动态表情，角色坐标信息</strong>的显示等部分，在开发过程中需要着重注意。</p>
<blockquote>
<p>这里我的一个疑问是如果划分过细，过多的Canvas是否会导致UGUI有额外开销？比如是否不同Canvas上的界面元素即使使用Batch后的图，也无法合并Draw Call？这是在开发中需要注意权衡的一个点。</p>
</blockquote>
<p>之前有讨论过<code>动静分离</code>的概念，但是进行分离的基本规则和原理并不是很清楚，张鑫博士的沙龙从性能分析的具体数据出发，结合具体函数的作用，讲解得清晰透彻。<br>另外有几点关于ui优化的笔记：</p>
<blockquote>
<ul>
<li>NGUI中UITexture不会被合并，建议使用UISprite；（我们项目目前使用UGUI，因此NGUI的不是很熟悉，不知道UGUI中有没有无法合并的控件？）</li>
<li>UI应该尽量避免重叠，尤其是看上去不重叠但是实际上有半透区域存在重叠，会导致Unity不进行合并操作，增加Draww Call数量。</li>
<li>在Unity 5.2之后的版本中，ui控件的z值不为0的情况下不会进行合并。（不知道这是为了解决遮挡或者什么问题而修改的<code>特性</code>，还是Bug，在制作的时候注意一下，尤其是做角色的3D血条有深度更改需求的情况下。）</li>
<li>背包界面的优化中提到了<strong>PixelPerfect的设置</strong>，这是一个对齐像素的效果可以让字体等显示的效果更好，比如在背包内容滚动的时候，每帧都会有比较大的消耗在这上面，可以<strong>考虑关闭掉</strong>。</li>
<li>UI中Mesh需要的顶点数量如果可以控制在<strong>1000以内</strong>，Mesh合并的效率就会比较好。过多的顶点数量在全部是静态的情况下问题不大，但是一旦涉及到动态界面就会造成卡顿。</li>
<li>UI部分的Draw Call建议控制在<strong>20~30之间</strong>，是一个比较理想的情况。</li>
</ul>
</blockquote>
<h2 id="2-血条优化案例"><a href="#2-血条优化案例" class="headerlink" title="2. 血条优化案例"></a>2. 血条优化案例</h2><p>UWA做了一个血条性能分析的Demo，也是和UI有关。</p>
<p>通常MMO游戏中血条会比较多，比如一些PVP或者PVE玩法中，血条会有几十个甚至上百个，他们会随着怪物的死亡等消失，又会随着新的怪物产生而重新出现。这里需要注意的点有如下几个:</p>
<blockquote>
<ul>
<li>通常比较直接的思路是创建一个缓冲池，用完丢回去，需要的时候先冲池子里拿。这里依然会有一些性能问题，因为放回缓冲池的操作和重新放回场景中的操作会有SetParent的过程，在UGUI中这一过程会导致控件进行一系列的初始化操作，造成卡顿等问题。UWA的建议是使用移除视窗之外的操作来代替SetParent操作，可以提升性能。</li>
<li>在掉血跳字等字体的部分美术同学喜欢使用Outline等效果，一次Outline对于一个字来说会多绘制上下左右4遍，因此对于内容可控的部分建议直接使用 <strong>静态字体</strong>。</li>
<li>对于频繁出现又消失的战斗提示信息等部分，可以使用<code>.text = ”“</code>的赋值操作，即把文本的内容赋值为空的方式来代替Active和Deactive。</li>
<li>如果血条非常多的情况下，可以考虑拆分成多个Canvas，会有一些意想不到的优化效果。UWA做测试观察到现象是每个Canvas的性能消耗与其中的血条数量不是成正比的，而是一种超线性的关系，这可以理解，在每一控件都可能发生变化的情况下，需要重建整个Canvas，那这是一个n*n的关系。（当然说是n^2的关系也不准确，因为每帧改变1个和改变n个都只会重建一次，但是从统计概率上来说，数量越多，每帧需要进行Mesh重建的概率就越大，重建消耗也是越大的，因此是超线性的。）这里还是一个需要进行Draw Call和重建消耗的折中考虑的点。</li>
</ul>
</blockquote>
<h2 id="3-多线程渲染"><a href="#3-多线程渲染" class="headerlink" title="3. 多线程渲染"></a>3. 多线程渲染</h2><p>多线程渲染是我在网易的时候跟过的一个大坑。。。当然不是我做的开发，而是我们项目比较早在使用引擎组做的这一功能，从集成过程到做兼容性测试遇到过很多问题，比如某些设备上莫名其妙的Crash。</p>
<p>张鑫博士说他们从他们的经验来看，Unity 5.3版本之后多线程渲染的功能已经是一个比较稳定的版本了，现在已经有正在运营的项目在开启多线程渲染。因此整体上还是可以比较放心地开启的。多线程渲染对于PostEffect的提升效果很大，他们做了一个测试可以让CPU消耗从平均20ms降低到平均2ms，也有项目开始之后出现顿卡。</p>
<p>与之前了解的一样，开启多线程渲染之后的性能提升效果根本上和是CPU瓶颈还是GPU瓶颈有关，不同设备效果不同，不同游戏的瓶颈也不同，因此要各个项目自己测试来看，因此UWA官方的说法是——</p>
<blockquote>
<p>”推荐各个项目<strong>尝试开启</strong>。“</p>
</blockquote>
<p>这部分提到如果在观察Profile面板时发现WaitingForJob很高，就说明CPU在等子线程，就已经有性能问题了，当出现PutGeometryJobFence的时候，性能问题就已经很严重了。</p>
<h2 id="4-动态阴影的技术方案"><a href="#4-动态阴影的技术方案" class="headerlink" title="4. 动态阴影的技术方案"></a>4. 动态阴影的技术方案</h2><p>MMO开发中角色阴影已经成为了一个标配，UWA经过测试，Unity官方的Build-in ShadowMap的性能还是最好的，推荐使用，只是效果相对差，而且在Mobile设备上无法支持原生的软影（存疑，需要自己测试一下效果）。</p>
<p>而Projector的实现方式比较适合只有一个角色需要阴影的情况，推荐了两款插件：</p>
<blockquote>
<ul>
<li>Fast Shadow Projector 只支持静态物体；</li>
<li>Fast Shadow Receivor 可以将接受阴影的物体拆分出需要阴影的独立的mesh，提升渲染速度，可以支持柱子这样非平面的物体。</li>
</ul>
</blockquote>
<p>阴影这块是我们项目目前要研究的重点内容之一，我们在考虑全部动态阴影的方案来部分替代烘焙的LightMap。这部分市面上的产品只观察到韩国的两款Unreal的手游这么来做，之前在网易内部使用Forward Lighting一直都是烘焙的方案。这块如果有朋友了解什么信息还希望不吝赐教~</p>
<h2 id="5-资源的同步和异步加载"><a href="#5-资源的同步和异步加载" class="headerlink" title="5. 资源的同步和异步加载"></a>5. 资源的同步和异步加载</h2><p>这是比较有意思的一块内容，之前的思路一直都是大部分情况下统一使用异步加载，只有在明确知道资源非常小，而且不重要的模块使用同步加载的方案，比如一个只有几个面的dummy model之类的。</p>
<p>UWA给出的建议是：在Loading界面中，如果需要表现平滑的加载进度和加载界面的话，可以使用同步加载，其他的过程中使用异步加载。原因是——</p>
<blockquote>
<p>”我们观察到，在对于同一个资源，同步加载比异步加载所花费的时间要少很多。异步加载会把任务拆分成比较小的粒度到每帧执行，但是在设备上每帧33ms的时间中，往往用不了这么久异步加载任务就执行完毕了，比如16ms甚至更少的时间，这就导致了无谓的等待。”</p>
</blockquote>
<p>如果觉得加载时间过长，而对于加载过程中的玩家体验不需要过多关注的项目可以参考这一思路。这的确是我之前的经验所没有包含的部分。</p>
<p>另外，在Unity中，对于异步加载来说，也可能会造成顿卡，因为不是所有的过程都是异步的。IO部分可以做到完全异步，但是内存中的初始化的部分过程可能仍然是同步的，比如一张1024<em>1024大小的贴图异步加载，通常设备上都会可以感受到卡顿，因此建议<em>*大于这个尺寸的贴图统一进行预加载</em></em>。</p>
<p>与此相关的还有一个Unity的小知识。Unity默认每帧给2ms的时间让CPU拷贝内存东西到GPU中，比如贴图、网格顶点等，默认的Buffer是4M大小，因此这里也会影响资源加载到最终渲染到屏幕上的时间。这两个参数是可以调整的，具体接口参考官方文档。另外默认4M正好是一张32位的1024<em>1024大小的贴图大小，如果使用了2048</em>2048或者更大的贴图格式，这个Buffer会增大为对应的大小，并且不会在缩小回来。因此建议资源中的最大尺寸可以给一个定义，尽量不要出现只有偶尔几张贴图使用非常大的尺寸的情况。</p>
<h2 id="6-动画模块的优化"><a href="#6-动画模块的优化" class="headerlink" title="6. 动画模块的优化"></a>6. 动画模块的优化</h2><p>除了常规的降低骨骼数量和动画曲线数量之外，Unity 5.2之后提供了一个culling Group的功能，用在模型位置一直绑定一个球的方式做碰撞体来优化判定，不在视锥范围的的物体不进行Animator的Update。这一功能主要针对脚本逻辑的Update，Animator没有提供单独的接口根据距离来控制Update频路，一个可行的思路是自己重写其Update接口，然后传入更高的Delta Time来模拟降频的功能。不过以我之前用Havok的降频功能来做性能对比的话，除非角色数量非常高，否则这部分骨骼骨骼的更新的优化空间不是非常大，不过Unity这块具体的数据要进行测试才知道。</p>
<p>Animator中有一个Optimize Game Objets的选项，可以降低Update的消耗，UWA建议使用。这是因为默认情况下每根骨骼都是一个GameObject，每帧骨骼更新之后会需要修改它们的Transform。</p>
<blockquote>
<p>“当打开这个选项，导入的角色中的游戏对象transform hierarchy将会被移除，而且以Avatar and Animator组件替代。<br>角色的SkinnedMeshRenderer将会直接使用Mecanim内部骨骼，因此我们能摆脱所有用于描述骨头的Transform。<br>这个选项将提升动画角色的性能，推荐最终产品开启这个选项。优化模式下，皮肤网格模型的抽取也是多线程的。<br>当开启了这个选项，用户能在ModelImporter inspector中指定“Extra Transforms to Expose”的列表。例如，如果你想附加一把剑道右手，这是一个挂载点。暴露的transform在游戏对象的hierarchy中是平行的，不管它在骨架视图中的深度”</p>
</blockquote>
<p>对于Animator的Active和Deactive的操作有很大的性能消耗，这在之前斗鱼上的直播中已经提到过了，这里还是像ui一样，建议将角色移出视窗之外的方式来进行缓存，或者只把组件Active和Deactive，来提升性能。</p>
<h2 id="7-其他的小tips"><a href="#7-其他的小tips" class="headerlink" title="7. 其他的小tips"></a>7. 其他的小tips</h2><p>除了上述的一些问题之外，还有一些比较了零碎的笔记，不进行赘述，只记录如下：</p>
<blockquote>
<ul>
<li>渲染面数建议控制在10w面一下，这是目前经过大量测试性价比比较高的一个点，5w-10w面测试看下来差别不是很大，Draw Call数量建议控制在200-300以内，比较好的情况是在100以下。</li>
<li>粒子系统通常需要加载的资源很多，但是初始化过程比较消耗CPU，因为通常一个粒子系统中的Component很多，建议进行预加载。</li>
<li>粒子系统中的PreWarn选项会在后台进行一次完整周期的模拟，因此使用可能会有卡顿。</li>
<li>Skined Mesh引擎是不会进行合并的，MeshBaker插件可以减低Draw Call数量，对于动态的物体也可以，但是会影响裁剪，而且动态添加和删除很慢，通常用于ARPG游戏中的优化，MMO较为少用。</li>
<li>注意创建Mesh和Material的拷贝过程，比如修改一个Material的参数，会创建一个新的Material对象，频繁地执行这样的操作会有泄漏出现，推荐使用DynamicMaterial，缓存然后只修改这一个动态材质的方法。</li>
</ul>
</blockquote>
<h2 id="8-大世界场景拆分和动态加载"><a href="#8-大世界场景拆分和动态加载" class="headerlink" title="8. 大世界场景拆分和动态加载"></a>8. 大世界场景拆分和动态加载</h2><p>这一部分是张强同学做的讲座，基于地形的方式实现了的大世界动态加载功能。其实这部分本来是我期望去听和讨论的部分，以为我们项目正好在进行这块的技术预研，但是我们不是使用地形，而是基于静态Mesh，另外视角我们更倾向于平视而非2.5D，因此这部分对于我们的帮助没有想象中的大。</p>
<p>我个人觉得这部分的一个问题是整个工程是基于一个Demo性质的实现，而非正式的项目，因为时间关系没有在后面进行深入的交流，因此也不清楚目前的实现是否在正式的项目中应用了。一些应用方面的疑问其实讲座正文中没有讲到：</p>
<blockquote>
<ul>
<li>结合到美术制作，地块的拆分建议遵循的原则是什么？比如多少个屏幕范围划分为一块比较合理？</li>
<li>如果使用lightmap的方案，两个地块交接处是否会有问题，比如交界处左侧有一座山，它的投影可能会在另外一个拆分后的地块上，如果拆分后再Bake，是否有解决方案可以处理这样的问题？</li>
<li>如果使用平视视角，目前有没有什么比较好的解决方案？LOD的话有哪些注意事项？</li>
</ul>
</blockquote>
<p>这部分可以直接参考官方给出的PPT，我做的笔记不太多，这里只放了一些没有来及提出的问题，幸好加了两位主持人的微信，回头整理好问题再一并请教，有答复了再修改本文。</p>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>这次上海之行，一天时间往返上海杭州，只为了这两场讲座。从收获来说，虽然和预期稍有不同，但是还是很值得的。感谢张鑫博士和张强同学两位主持人的分享，你们辛苦啦~也感谢UWA公司组织这样免费的技术沙龙，祝愿贵公司越来越好~~</p>
<p>2016年11月27日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unitydev1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/18/unitydev1/" class="article-date">
  	<time datetime="2016-10-17T16:11:50.000Z" itemprop="datePublished">2016-10-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/18/unitydev1/">Unity手游开发札记——Lua语言集成</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>2016年8月从网易“毕业”，在新的公司开始新的工作，这其中的波折与故事暂时不提，等以后有时间的时候再另开文章总结回顾。全新的手游项目从零开始，使用Unity引擎开发一款手游项目，本系列札记主要针对开发过程中重要的部分进行记录和总结，一方面方便自己日后回顾，也希望可以给遇到类似问题的朋友一些提醒和启发。当然，自己在Unity引擎和Lua语言方面都是新手，更加希望抛砖引玉，针对遇到的问题进行更广泛的讨论和更多大牛的提点。<br>具体到本篇文章的主题，主要是Lua语言和Unity引擎的集成。这是我最近一个月左右的时间一直在尝试解决的问题，本文主要记录方案的选择和对比，以及针对选择的方案自己进行的一些改造和思考。</p>
<h2 id="1-为什么要集成Lua语言"><a href="#1-为什么要集成Lua语言" class="headerlink" title="1. 为什么要集成Lua语言"></a>1. 为什么要集成Lua语言</h2><p>有句从知乎开始发展起来的名言叫做——“先问是不是，再问为什么”，类似地，在做一个技术方案的时候，“先问为什么，再考虑如何做”。那我们第一个问题就是要解决这个项目“为什么要集成Lua语言”？<br>在网易内部，一向遵守的传统是逻辑用脚本来做，比如Python、Lua等，好处主要有如下几点：</p>
<ul>
<li>利用脚本语言的动态特性，客户端可以做Hotfix，服务端可以做Refresh，无论在运营还是开发期这一特性都很有用；</li>
<li>脚本语言运行在虚拟机中，它把游戏进程搞挂的概率相比C/C++等静态语言要低；</li>
<li>脚本语言相对好学习一些，对于新手来说上手难度较低，比如Python，当然要精通也需要时间和经验的积累；</li>
</ul>
<p>当然还有其他的优点，对应的缺点就在于运行效率比C/C++低不少，相对于静态语言在编译器有完备的语法检查，动态语言更容易出一些运行时的错误，调试难度相对大一些。<br>而对于Unity引擎，因为它已经选择了C#作为对应的脚本语言，因此再集成一门Lua语言显得有些多余。核心的原因还是在IOS设备上因为使用了IL2CPP，无法实现像Android上面那样直接替换DLL的方式来进行更新，这导致游戏逻辑如果出现错误，不但无法Hotfix修复，甚至连Patch都不能修复，只能重新提包。虽然APP Store现在对于应用的审核速度已经变快， 但是仍然需要2-3天以上的时间，这对于需要快速反应的商业游戏来说是无法容忍的。<br>目前了解到的业内常用的做法主要有如下几种：</p>
<ul>
<li>纯C#开发的方式，比如腾讯这种大厂，某些工作室的做法就是完全使用C#来进行开发，尽量做到功能逻辑可配置，这样出现某些重大问题可以通过更新数据的方式把逻辑暂时关闭掉。逻辑的更新安卓使用替换DLL的方式，IOS使用重新提包的方式。对外测试以安卓为主，并且大厂有比较好的QA团队进行质量保证，因此可以做到IOS最终上线的品质和bug都是相对少的。</li>
<li>C#做核心逻辑，Lua做UI和活动玩法等执行频率低，需求变动较大的部分。这是目前了解到的一些创业团队使用得比较多的做法，在效率和可更新性之间的一个折中。</li>
<li>以Lua为主的方式。也了解到一些公司的团队，包括网易内部的一些项目，使用逻辑都以Lua语言来写的方式进行开发。从网易之前的经验来看，逻辑使用纯脚本的方式并不会有太大问题。</li>
</ul>
<p>我们要开发的产品是一款商业游戏，对于出现问题快速响应的需求相对强烈，因此在Unity中使用Lua语言是必不可少的，至于多大范围地应用它，初步是计划大部分功能都是用Lua语言来开发，并制定每隔一段时间周期进行性能测试和评估的方式来确保性能可以满足需求。</p>
<p>##2. 怎样集成Lua语言<br>在决定要使用Lua语言之后，要面临的问题就是如何在Unity中去集成它。可选的方案有很多，各种方案的实现原理也不尽相同，早期有各种在C#语言内部实现Lua虚拟机的，也有利用反射动态查找脚本的，但是目前比较主流的两种方案是<a href="https://github.com/topameng/tolua" target="_blank" rel="external">ToLua#</a>和<a href="https://github.com/pangweiwei/slua" target="_blank" rel="external">SLua</a>这两种方案。</p>
<h3 id="2-1-性能对比测试"><a href="#2-1-性能对比测试" class="headerlink" title="2.1 性能对比测试"></a>2.1 性能对比测试</h3><p>这两个方案的原理都相似，基于LUAInterface，在开发时将C#的接口导出为Lua的版本，通过LuaState的栈结构来进行两种语言之间方法调用。这两个开源项目针对性能对比在网上打了不少口水仗，到底谁更优秀很难公允地评价，因为作为一个中间件性质的开源项目，除了性能之外还有生态圈、易用性等各个方面的问题需要考量。网上有不少对比的帖子可以自己搜索一下，这里不进行详述了，以免引起论战。<br>在这一部分我们最终选择了ToLua#，原因我是自己在安卓设备上进行测试了结果。钱康来前段时间发了一个帖子来对比几款Unity中Lua集成方案的性能，<a href="http://qiankanglai.me/2016/07/31/unity-lua/" target="_blank" rel="external">Unity常见lua解决方案性能比较</a>，这篇文章也整理投稿到了<a href="http://blog.uwa4d.com/archives/lua_perf.html" target="_blank" rel="external">UWA博客</a>中，我自己基于测试用例在锤子T2上进行了简单的性能测试，结论和这篇博客中的基本一致，未整理的数据如下表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">框架</th>
<th style="text-align:center">test1</th>
<th style="text-align:center">test2</th>
<th style="text-align:center">test3</th>
<th style="text-align:center">test4</th>
<th style="text-align:center">test5</th>
<th style="text-align:center">test6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SLua</td>
<td style="text-align:center">755.004</td>
<td style="text-align:center">623.619</td>
<td style="text-align:center">34.126</td>
<td style="text-align:center">6812.41</td>
<td style="text-align:center">1648.68</td>
<td style="text-align:center">0.6352</td>
</tr>
<tr>
<td style="text-align:center">ToLua#</td>
<td style="text-align:center">634</td>
<td style="text-align:center">871.2</td>
<td style="text-align:center">297.8</td>
<td style="text-align:center">3056.2</td>
<td style="text-align:center">1139.4</td>
<td style="text-align:center">1.206</td>
</tr>
</tbody>
</table>
<p>数据的单位是毫秒，测试是进行五次测试的平均值，使用锤子T2进行。这次测试并不严谨，只是为了亲自验证一下两者之间的性能差异到底是什么样子的。每一个测试用例的代码可以参考前文提到文章，这里只简单进行说明：</p>
<ul>
<li>test1是简单的属性操作；</li>
<li>test2和test3是向量的操作；</li>
<li>test4是GameObject的创建；</li>
<li>test5是创建GameObject并进行一些属性操作；</li>
<li>test6是对四元数进行操作。</li>
</ul>
<h3 id="2-2-性能差异的可能原因之一"><a href="#2-2-性能差异的可能原因之一" class="headerlink" title="2.2 性能差异的可能原因之一"></a>2.2 性能差异的可能原因之一</h3><p>个人感觉ToLua#在属性操作方面性能较好，而Vector的向量操作，因为可能会有Lua层的优化，即在Lua层完全实现了对应的操作，因此需要针对源码进行详细的对比。至于性能差异的原因，我没有从Lua虚拟机的实现部分分析，只是查看两种生成Warp后的接口进行一个简单的猜想。<br>选取同一个接口进行对比，UnityEngine.Animator的GetFloat接口，ToLua#的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class="line">static int GetFloat(IntPtr L)</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		int count = LuaDLL.lua_gettop(L);</span><br><span class="line"></span><br><span class="line">		if (count == 2 &amp;&amp; TypeChecker.CheckTypes(L, 1, typeof(UnityEngine.Animator), typeof(int)))</span><br><span class="line">		&#123;</span><br><span class="line">			UnityEngine.Animator obj = (UnityEngine.Animator)ToLua.ToObject(L, 1);</span><br><span class="line">			int arg0 = (int)LuaDLL.lua_tonumber(L, 2);</span><br><span class="line">			float o = obj.GetFloat(arg0);</span><br><span class="line">			LuaDLL.lua_pushnumber(L, o);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		//此处省略另一个重载接口</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return LuaDLL.luaL_throw(L, &quot;invalid arguments to method: UnityEngine.Animator.GetFloat&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(Exception e)</span><br><span class="line">	&#123;</span><br><span class="line">		return LuaDLL.toluaL_exception(L, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> SLua生成的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class="line">static public int GetFloat(IntPtr l) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		int argc = LuaDLL.lua_gettop(l);</span><br><span class="line">		if(matchType(l,argc,2,typeof(int)))&#123;</span><br><span class="line">			UnityEngine.Animator self=(UnityEngine.Animator)checkSelf(l);</span><br><span class="line">			System.Int32 a1;</span><br><span class="line">			checkType(l,2,out a1);</span><br><span class="line">			var ret=self.GetFloat(a1);</span><br><span class="line">			pushValue(l,true);</span><br><span class="line">			pushValue(l,ret);</span><br><span class="line">			return 2;</span><br><span class="line">		&#125;</span><br><span class="line">		//此处省略另一个重载接口</span><br><span class="line">		pushValue(l,false);</span><br><span class="line">		LuaDLL.lua_pushstring(l,&quot;No matched override function to call&quot;);</span><br><span class="line">		return 2;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(Exception e) &#123;</span><br><span class="line">		return error(l,e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，这一函数只需要一个返回值的，但是SLua往栈里pushValue了两个值，然后返回2，第一个值是一个bool值，它应该是用于标识函数调用是否成功。在不了解其他地方是否有性能差别的情况下，这里应该是ToLus#和SLua在简单的接口调用上的性能差别的原因之一。SLua使用一个单独的值来表示函数运行结果，这对于错误可以进行更好的处理，但是多出的压栈和出栈操作有额外的性能消耗。</p>
<h3 id="2-3-导出方式对比"><a href="#2-3-导出方式对比" class="headerlink" title="2.3 导出方式对比"></a>2.3 导出方式对比</h3><p>ToLua#导出使用的是白名单的方式，在CustomeSettings.cs文件中定义的接口才会导出，也提供了导出引擎所有的接口的功能；而SLua是以黑名单的方式进行，默认提供的功能是导出除了黑名单中的所有模块接口，也提供了一个导出最简接口的方式。<br>从使用角度来看，SLua黑名单的方式在开发期比较方便，默认会导出所有接口，因此不需要每次想要增加一个已经存在的类的Lua接口都要自己定义然后重新导出，发布的时候也可以使用最简接口的方式导出。维护起来ToLua#因为所有的导出类都是我们自己定义的，因此更加清晰明确。<br>鉴于这部分内容有源码可以进行修改，因此不是一个核心需要考虑的内容，两种方式各有利弊。</p>
<h3 id="2-4-我们的选择"><a href="#2-4-我们的选择" class="headerlink" title="2.4 我们的选择"></a>2.4 我们的选择</h3><p>至于这一点是否是性能差别的主要原因，因为没有时间和精力阅读其他部分的源码，暂时也不太好进行对比和评价。出于性能的考虑，我们项目决定使用ToLua#作为Lua部分集成的方案，并且以接口的形式进行封装，来保证后面替换的可能性。</p>
<h2 id="3-如何使用Lua语言"><a href="#3-如何使用Lua语言" class="headerlink" title="3. 如何使用Lua语言"></a>3. 如何使用Lua语言</h2><p>在进行了初步集成之后，怎样让开发人员可以更好地使用Lua语言是接下来要面临的问题。ToLua#对应有一套之前ulua作者开发的<a href="https://github.com/jarjin/LuaFramework_UGUI" target="_blank" rel="external">LuaFramework</a>，这一个框架集成了脚本打包和二进制脚本读取、UI制作流程等多个功能，但是也如作者自己所说，这一框架最初源自一个示例形式的Demo，因此其中代码有很多部分是和示例写死绑定的逻辑，比如启动逻辑、Lua二进制脚本的加载需要手动指定等等。<br>相对应的，SLua也有多套已经开源的框架，其中最为完善的是<a href="https://github.com/mr-kelly/KSFramework" target="_blank" rel="external">KSFramwork</a>，这套框架集成了资源打包、导表、Lua热重载在内的多个功能，而且代码质量初步看起来还不错，因此最终我们决定把KSFramwork中的SLua部分替换成ToLua#的部分来结合使用。<br>改造的过程还比较简单，由于该部分使用Lua耦合的只有两块内容，一是UIControler部分，二是LuaBehavior部分，所有的接口都由LuaModule模块提供。因此改造的过程也就比较明确了：</p>
<ol>
<li>删除源代码中的SLua部分，接入ToLua#的部分；</li>
<li>使用ToLua#重写LuaModule的实现；</li>
<li>改造LuaUIController，使用新的LuaModule接口实现之前的功能；</li>
<li>改造LUABehavior模块。</li>
</ol>
<p>代码删除和LuaModule模块的重新实现都比较简单，着重介绍一下LuaUIController和LUABehavior模块的改造。</p>
<h3 id="3-1-改造初衷"><a href="#3-1-改造初衷" class="headerlink" title="3.1 改造初衷"></a>3.1 改造初衷</h3><p>之前的KSFramwork还是一个核心逻辑在C#，Lua只承载UI等逻辑的模块，这与我之前从网易“继承”的“轻引擎，重脚本”的思路并不契合。在这一思路下，引擎可以看做渲染、资源加载、音效等功能的提供者，脚本逻辑负责使用这些功能构建游戏内容。那这样大部分与逻辑相关的控制权就应该从引擎交给脚本部分来进行。Unity作为一个比较特殊的例子，虽然对于它来说，C#部分已经是脚本了，但是对于希望着重使用Lua脚本的我们来说，因为C#不可更新，因此被视作了引擎部分。<br>最为简单的设计就是当引擎初始化完毕之后，通过一个接口调用把后续的逻辑都交由脚本来控制，大部分与游戏玩法相关的模型加载、声音播放、特效播放、动画播放等由脚本来控制。tick逻辑为了减少调用次数，每帧也由引擎调用注册的一个脚本接口进行统一调用，脚本层自己做分发。</p>
<h3 id="3-2-LuaUIController的改造"><a href="#3-2-LuaUIController的改造" class="headerlink" title="3.2 LuaUIController的改造"></a>3.2 LuaUIController的改造</h3><p>LuaUIController原始的方式是在C#层通过ui模块的名称加载对应的一个lua文件，获取一个lua table进行缓存，在比如OnInit等需要接口调用的地方查找这个table中对应的函数进行调用。这种方式的界面是由C#层的逻辑来驱动加载和显示的，而且在加载过程中要有文件的搜索和检查过程。<br>这样会存在一个问题，就是脚本层的逻辑无法或者很难去控制界面对象的生命周期。针对资源的生命周期，“<strong>谁创建谁管理</strong>”的策略不再可以很方便地来明确责任的划分，因此要进行改造。<br>改造的方向很简单，将界面加载和显示的接口开放到Lua层，然后在创建的时候由lua层传递一个table对象进来，C#中进行缓存，当界面资源异步加载完毕，需要进行接口调用的地方的实现与之前保存一致。这样，界面资源的生命周期全部交由脚本层来管理，在脚本构建一个结构合理功能齐全的UIManager来进行一些功能的封装，就可以满足大部分的需求。</p>
<h2 id="3-3-LuaBehavior的改造"><a href="#3-3-LuaBehavior的改造" class="headerlink" title="3.3 LuaBehavior的改造"></a>3.3 LuaBehavior的改造</h2><p>MonoBehavior是Unity为了放便开发而提供的一个很好的功能，脚本以组件的方式挂接在GameObject身上，就可以在Awake、Start、Update等接口中处理想要的逻辑。为了能够继续使用Unity的这一特性，在Lua层也实现了一个简单的LuaBehavior封装。<br>KSFramwork中的思路非常简单，同样根据名称来把一个LuaBehavior和一个Lua脚本进行绑定，在对应的逻辑中调用与之对应的接口就可以了。比如Awake接口的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Awake()</span><br><span class="line">&#123;</span><br><span class="line">    if (!string.IsNullOrEmpty(LuaPath))</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        CallLuaFunction(&quot;Awake&quot;);</span><br><span class="line">    &#125; // else Null Lua Path, pass Awake!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>CallLuaFunction</code>的实现也很明确，从缓存的lua table中获取名称为Awake的function进行调用。这种方式没有问题，但是当场景中挂载了LuaBehavior的GameObject很多的时候，每一帧都会有非常多次的update方法调用，这个调用从C#层传递给Lua层，有很多额外的性能消耗。<br>前文也提到了，比较好的方式是每帧只有一个C#到Lua层的Update方法调用，然后脚本层自己做分发。因此，针对这一需求，我们使用ToLua#自带的LuaLooper来实现这一功能。<br>LuaLooper是全局只创建一个的MonoBehaviour，注意这里只创建一个是由逻辑来决定的，而不是一个单例模式。这里针对单例模式适用场合的讨论不再展开，此处由逻辑来保证只有一个Looper存在是一件比较合理的事情，预留了一些扩展的可能。<br>LuaLooper以事件的方式将三种Update分发出去：Update、LateUpdate、FixedUpdate，它在自己对应的函数中调用luaState的对应函数来将事件告知脚本，脚本中需要的模块向分发模块注册回调来监听事件，就可以做到每帧只有一次Update调用了。<br>具体的代码实现可以去看ToLua#中的LupLooper.cs的类实现。</p>
<blockquote>
<p><strong>注意</strong> 这里有一个需要小心的点是当事件在脚本层分发的时候，要注意执行时序问题的影响，最好能够保证任意的执行顺序都可以不影响游戏逻辑的结果，否则可能会出现很难查的诡异bug。</p>
</blockquote>
<p>对于Awake、Start等一次性调用的函数，由于不是频繁的逻辑，因此保留了原始的实现方式，这样可以让Lua层对应的代码实现更加简洁。而使用事件注册的方式，让不需要update逻辑的脚本没有任何额外的性能消耗。</p>
<h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>只有上述的这些部分，对于开发一款商业游戏来说还远远不够，但是通过导出的接口和对于KSFramwork的一些改进，已经可以实现一个简单的由Lua层来驱动的Demo了，它可以加载场景，打开一个打包成AssetBundle的界面，设置界面上的控件属性，为按钮添加一些回调时间，然后切换场景，加载一些打包在AssetBudnle中的Prefab模型。<br>这是Lua初步集成的结束，也是在这款游戏中创造万物的开始。</p>
<p>2016年10月18日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/pythonadvance6/" class="article-date">
  	<time datetime="2016-07-10T16:06:50.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/pythonadvance6/">Python进阶(六)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讨论完Callable相关的部分之后，我们继续来看一下Class相关的两个东西——Property和super。</p>
<h2 id="9-Property"><a href="#9-Property" class="headerlink" title="9. Property"></a>9. Property</h2><p>这部分其实比较简单，属于Python的基本内容，也是工作中经常用到，比如做属性封装，在属性访问的时候添加一些自己想要做的事情。直接看一个简单的代码例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">		self._a = a</span><br><span class="line">		self._b = b</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_get_a</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._a</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_set_a</span><span class="params">(self, a)</span>:</span></span><br><span class="line">		self._a = a</span><br><span class="line">	a = property(_get_a, _set_a)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_get_b</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._b</span><br><span class="line">	b = property(_get_b)</span><br><span class="line">	</span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a1 = A.a</span><br><span class="line">a2 = A.a</span><br><span class="line">a3 = a.a</span><br><span class="line">a4 = a.a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(a1), id(a2), id(a3), id(a4), id(a._a)</span><br><span class="line"><span class="keyword">print</span> a1, a2, a3, a4</span><br><span class="line"><span class="keyword">print</span> a1.fget, a1.fset</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">39712928</span> <span class="number">39712928</span> <span class="number">39745760</span> <span class="number">39745760</span> <span class="number">39745760</span></span><br><span class="line">&lt;property object at <span class="number">0x025DF8A0</span>&gt; &lt;property object at <span class="number">0x025DF8A0</span>&gt; <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&lt;function _get_a at <span class="number">0x02C677F0</span>&gt; &lt;function _set_a at <span class="number">0x02C677B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们担心会有类似bound method或者unbound method的机制，所以尝试用两个变量来保存A.a和a.a，发现他们的id并不会变化，说明它们在Ptyhon中是一个稳定的对象，而非在需要是动态创建的。当然，A.a和a.a并不是同一个对象，把他们分别输出出来就可以看到，A.a是一个property对象，而a.a直接访问到了a对象身上的_a属性。通过id方法可以看到a3、a4和a._a其实是一同一个对象。<br>关键词property其实是一个class，当访问它的时候，代理对象会用对应的方法进行替换，支持的方法包括fget、fset和fdel。</p>
<h2 id="10-super"><a href="#10-super" class="headerlink" title="10. super"></a>10. super</h2><p>对于super这个关键词的使用其实算是Python的基础知识了，我们从一个简单的例子来探究一下，Python为什么从2.2版本加入这个关键词，它的使用带来我们什么样的便利和困扰？<br>先来看最为简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in A'</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in B'</span></span><br><span class="line">		A.__init__(self)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in C'</span></span><br><span class="line">		super(C, self).__init__()</span><br><span class="line">		</span><br><span class="line">b = B()</span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> super(A, c)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in B</span><br><span class="line">in A</span><br><span class="line">in C</span><br><span class="line">in A</span><br><span class="line">&lt;super: &lt;class 'A'&gt;, &lt;C object&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>结果很简单，无需过多的解释，输出的信息显示了构造的过程，唯一需要指出的是super是一种buildin class。那么它是怎样工作的呢？也就是构造B的时候是如何确定它要调用到的父类方法的呢？<br>在C++中，有虚函数表的结构，用于实现继承中动态多态的特性。在Python中，有<code>__mro__</code>属性来描述继承关系。什么是mro呢？mro是method resolution order，直译是“方法解决顺序”，但是这个不能很好地表达英文原文的含义，简单来说Python用它来解析方法的调用顺序。我们通过具体的例子来看一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in A'</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(B, self).__init__()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">b = B()     <span class="comment"># in A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> B.__mro__     <span class="comment"># (&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>B.__mro__</code>是一个元组，记录了对于B这个类来说的继承关系。在运行时，当调用<code>b.foo</code>方法的时候，会按照mro的顺序去依次查找含有此方法定义的对象或者类，直到找到为止，或者未找到会报错。注意这个过程是在<strong>运行时</strong>的，而非编译时，这也是python方法调用比较慢的原因之一。<br>super关键字也是通过这个数据结构来进行方法调用的，不同的是原理上，在存在的前提下，它会依次调用整个mro结构上的类上对应的方法。</p>
<blockquote>
<p><strong>思考</strong>：<code>__mro__</code>存在在哪里？</p>
</blockquote>
<p>看上去mro属性是一个数据，它似乎应该存储在B的身上，但是我们查看B的<code>__dict__</code>属性的时候发现其中并没有<code>__mro__</code>这个名称。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(B)</span><br><span class="line"><span class="comment"># ['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'foo']</span></span><br></pre></td></tr></table></figure></p>
<p>似乎又有神奇的事情发生了，<code>B.__mro__</code>是如何访问到的呢？我们知道，在没有定义metaclass的情况下，所有的类对象（<strong>类对象，并非类实例对象</strong>）都是一个type对象，那我们来用dir看一下type：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(type)</span><br><span class="line"><span class="comment">#['__abstractmethods__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__', '__dictoffset__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__weakrefoffset__', 'mro']</span></span><br></pre></td></tr></table></figure></p>
<p>Bingo！不但有<code>__mro__</code>，还有一个mro属性。<br>这里关于为什么放在type里，有一个stackoverflow的讨论可以参考下，本文不进行详述了：<br><a href="http://stackoverflow.com/questions/16663514/why-does-mro-not-show-up-in-dirmyclass" target="_blank" rel="external">Why does <strong>mro</strong> not show up in dir(MyClass)?</a></p>
<p>接着我们来回答第一个问题——Python为什么从2.2版本加入这个关键词？<br>在更早的版本中，当调用父类方法的时候，比如上面B继承自A的例子，需要手动调用<code>A.__init__(self)</code>，这样在需要重构A的时候，比如修改名称等，需要把所有继承自A的类中的代码都进行修改，这其实是不合理的一种设定。因此引入了super关键词处理这个过程，同时也为了实现super的功能添加了mro的结构。<br>在单继承结构下，mro可以很好的工作，多继承的情况下会否有什么问题呢？依然看一个简单的例子，C继承自A和B：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'enter A'</span></span><br><span class="line">		<span class="comment"># super(A, self).__init__()</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'level A'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'enter B'</span></span><br><span class="line">		<span class="comment"># super(B, self).__init__()</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'level B'</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in C'</span></span><br><span class="line">		super(C, self).__init__()</span><br><span class="line">		</span><br><span class="line">c = C()</span><br><span class="line">m = c.foo</span><br><span class="line"><span class="keyword">print</span> C.__mro__</span><br><span class="line"><span class="keyword">print</span> m.im_func, A.foo.im_func, B.foo.im_func</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in C</span><br><span class="line">enter A</span><br><span class="line">level A</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;)</span><br><span class="line">&lt;function foo at 0x029478B0&gt; &lt;function foo at 0x029478B0&gt; &lt;function foo at 0x02947830&gt;</span><br></pre></td></tr></table></figure></p>
<p>不太对哦，按照我们想要的结果，应当是通过super可以调用到父类A和父类B中的初始化方法才对！但是结果只调用到了A的，为什么？<br>细心的读者已经发现了，A和B中注释掉了两行super相关的代码，把它们的注释取消掉，输出结果就变成了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in C</span><br><span class="line">enter A</span><br><span class="line">enter B</span><br><span class="line">level B</span><br><span class="line">level A</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;)</span><br><span class="line">&lt;function foo at 0x02A37930&gt; &lt;function foo at 0x02A37930&gt; &lt;function foo at 0x02A378B0&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以调用到了A和B的初始化方法，注意，这里的调用过程是<strong>嵌套</strong>的。具体这是为什么，我这里偷懒，请参考关于super的经典文章：<a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">Python’s super() considered super!</a>，或者参考知乎的问题讨论：<a href="https://www.zhihu.com/question/20040039" target="_blank" rel="external">Python中既然可以直接通过父类名调用父类方法为什么还会存在super函数？</a></p>
<blockquote>
<p><strong>结论</strong>：super基于mro可以处理多重继承的调用关系，按照拓扑结构来进行，同层继承中遵守从左到右的继承顺序。<strong>但是</strong>，要注意所有的父类方法都正确使用super来进行调用，<strong>即使是直接继承自object的对象</strong>！否则可能产生方法调用不到的现象。</p>
</blockquote>
<p>需要额外指出的是，对于参数数目或者类型不同的情况，通过super的调用可能会导致trace，比如下面的例子就会有错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">		super(B, self).__init__(p1)</span><br><span class="line">		</span><br><span class="line">b = B(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(C, self).__init__(<span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">		super(D, self).__init__(p1, p2)</span><br><span class="line">		</span><br><span class="line">d = D(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> D.__mro__</span><br></pre></td></tr></table></figure></p>
<p>在原本A、B和C的继承结构可以正常工作的情况下，加入D，就会导致TypeError，解决的方法只能是按照最多的参数或者dict这种容器来设计函数的参数以兼容多种情况。</p>
<blockquote>
<p><strong>总结</strong>：在Python中，即使引入了super关键字和mro的机制来处理继承的情况，对于复杂的多重继承甚至菱形继承，还会出现很多问题，包括维护上和运行时的问题，因此本质上还是使用类似面向接口编程的方式来从根本上避免这种问题更好。</p>
</blockquote>
<p>PS：关于Python进阶的问题已经写了六篇了，在整理记录的过程中，我发现了一些听课时没有考虑过的新问题，也通过阅读其他的文档掌握新的知识，在简书上也收到了不少喜欢和关注。感谢引导我学习给我们讲课的同事大雄，然后感谢每一个阅读的读者，你有收获或者思考，我们彼此花的时间就都值得了。<br>关于基本的语言特性部分基本就包括上面的1-10个小节的内容，后面的课程内容关于gc和C++绑定等部分的，看时间慢慢整理。</p>
<p>2016年7月11日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/10/pythonadvance5/" class="article-date">
  	<time datetime="2016-07-10T13:03:25.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/pythonadvance5/">Python进阶(五)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="7-Function"><a href="#7-Function" class="headerlink" title="7. Function"></a>7. Function</h2><p>作为Callable部分第一个被提到，但是最后来分析它。原因其实很简单，我们已经发现前面的很多内容，包括bound method也好，static method也好，甚至operators，本质上都是function。<br>那么，如何去探究一个Python的Function的属性呢，阅读过前面内容的读者应该很明白了，通过一些简单的代码加上print就可以看到不少东西了。<br>我们先用dirf来看下一个function对象身上有什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b = <span class="number">10</span>)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(foo)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'func_closure'</span>, <span class="string">'func_code'</span>, <span class="string">'func_defaults'</span>, <span class="string">'func_dict'</span>, <span class="string">'func_doc'</span>, <span class="string">'func_globals'</span>, <span class="string">'func_name'</span>]</span><br></pre></td></tr></table></figure></p>
<p>不管双下划线开头的部分属性，我们只看对外开放的部分，先来看一看func_name属性吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> foo       <span class="comment">#&lt;function foo at 0x0235A2B0&gt;</span></span><br><span class="line">foo.func_name = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">print</span> foo       &lt;function abc at <span class="number">0x0235A2B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>func_name看上只是用来记录信息的一个名称而已，修改它并不会影响函数对象的调用。<br>我们再来看下func_defaults属性，看名称它是和默认值相关。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)			<span class="comment">#11</span></span><br><span class="line"><span class="keyword">print</span> foo.func_defaults		<span class="comment">#(10,)</span></span><br><span class="line">foo.func_defaults = (<span class="number">100</span>, )</span><br><span class="line">foo(<span class="number">1</span>)			<span class="comment">#101</span></span><br></pre></td></tr></table></figure></p>
<p>依然是把输出的结果放在代码行的后面以注释的形式给出，我们看到函数对象的func_defaults属性是一个元组，依次列出了所有默认参数。我们可以通过改变这个属性来改变已经被定义了的函数的默认参数。<br>为了可以看到func_closture的内容，我们构建一个闭包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> x + n</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">	</span><br><span class="line">f = bar(<span class="number">1</span>)</span><br><span class="line">g = bar(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">2</span>)		<span class="comment"># 3</span></span><br><span class="line"><span class="keyword">print</span> g(<span class="string">"def"</span>)	<span class="comment"># defabc</span></span><br><span class="line"><span class="keyword">print</span> foo.func_closure	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> f.func_closure	<span class="comment"># (&lt;cell at 0x029655F0: int object at 0x029378E0&gt;,)</span></span><br><span class="line"><span class="keyword">print</span> g.func_closure	<span class="comment"># (&lt;cell at 0x02A31130: str object at 0x02972AE8&gt;,)</span></span><br></pre></td></tr></table></figure></p>
<p>f和g是两个闭包对象，可以看到foo这个函数对象身上的func_closure属性为None，f和g身上分别是两个cell对象，这部分内容和闭包中讲的部分就契合在了一起。<br>func_code属性我们也来看一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bar.func_code</span><br><span class="line"><span class="keyword">print</span> dir(bar.func_code)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">foo.func_code = bar.func_code</span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出的结果由于比较长，写在了下面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;code object bar at <span class="number">02516</span>C80, file <span class="string">"C:\Users\David-PC\Desktop\Advanced Course on Python 2016\a014.py"</span>, line <span class="number">27</span>&gt;</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__cmp__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>, <span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_lnotab'</span>, <span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，func<em>code是一个code object，它有的属性有很多，基本以co</em>开头，如果有兴趣，可以自己一点点去把他们print出来看，也可以发现很多有趣的东西，这里暂时不进行展开。例子的另外一部分展示了func_code是可以被替换的。</p>
<blockquote>
<p><strong>扩展</strong>：关于code对象，可以阅读<a href="https://late.am/post/2012/03/26/exploring-python-code-objects.html" target="_blank" rel="external">Exploring Python Code Objects</a>，了解怎样通过compile方法来生成code object，以及code类的一些属性。</p>
</blockquote>
<p>关于function中比较重要的几个属性，以表格的形式总结出来。<br>| 属性名称      | 描述   |<br>| ——–      | —–:  |<br>| func_name     | 函数名称 |<br>| func_defaults |   函数的默认值列表   |<br>| func_code     |    函数体的code对象    |<br>| func_globals  |  函数的全局命名空间 |<br>| func_closure  | 函数的cell对象 |<br>看了function的这些属性，对于之前讨论过的hotfix是不是有了更深的了解呢？只需要替换一个函数对象的func_code，func_defaults，func_closure等属性，这个函数的行为就可以被改变了，结合上bound method和unbound method的动态生成的特性，对Python语言的动态性的原理的理解是否有更深入了一步呢？</p>
<h2 id="8-Classes"><a href="#8-Classes" class="headerlink" title="8. Classes"></a>8. Classes</h2><p>关于类，其实有很多可以讨论的内容，从生命周期的角度来看，一个C++类的对象包含如下四个生命周期：</p>
<ol>
<li>内存分配，malloc</li>
<li>调用构造函数初始化对象，A::A()</li>
<li>调用析构函数清理对象，A::~A()</li>
<li>释放内存，free</li>
</ol>
<p>不同的编译器在内存分配或者释放的时候具体使用的函数可能不同，但这四个步骤是都有的，而且在C++中，1和4两个步骤是隐式的，即开发者通常不需要去关心（当然也有可以去操作的方法），它们分别隐含在了构造函数和析构函数当中。<br>对于Python的对象来说，其生命周期包含如下三个部分：</p>
<ol>
<li>内存分配，<code>__new__</code>方法；</li>
<li>调用初始化(initializer)，<code>__init__</code>方法；</li>
<li>调用终结器(finalizer)，<code>__del__</code>方法；</li>
</ol>
<p>对于自定义的类，上述的过程可以通过重载对应的方法来实现对于其过程的控制。可以看到，这里并没有内存释放的过程，也就是说开发者无法主动控制对象所占用过的内存的释放，这一部分是方便开发者不需要进行内存的管理，另外也利于Python语言本身进行对象缓存池的设计与实现。这部分内容在bound method的部分已经看到了缓存池在Python的应用，更多的讨论放在内存管理的部分来进行。</p>
<blockquote>
<p><strong>思考</strong>：Python中如何实现单例模式？是否可以通过重载<code>__new__</code>方法，在每次分配内存的时候返回同一个对象来实现呢？</p>
</blockquote>
<p>答案是否定的，因为Python对于生命周期的控制决定了在<code>__new__</code>方法被调用，内存分配完毕之后会主动调用<code>__init__</code>方法，这样虽然分配的是同一个对象，但是多次<code>__init__</code>方法的调用可能会导致对象的属性被修改，可能会引发意料之外的bug，比如已经被修改过属性又被<code>__init__</code>方法改变等。</p>
<p>说了这些之后，对于Class我们返回Callable的主题，Python中的Class也是一个Callable的对象，调用一个类的结果很简单，就是获得一个类的实例化对象，我们来看一个简单的例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Foo 				<span class="comment"># &lt;class '__main__.Foo'&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo.__call__		<span class="comment"># &lt;method-wrapper '__call__' of type object at 0x029D33E0&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo()				<span class="comment"># &lt;__main__.Foo object at 0x02AAEED0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> func.__call__		<span class="comment"># &lt;method-wrapper '__call__' of function object at 0x029C77F0&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>类Foo是一个class对象，它是可以访问到<code>__call__</code>属性的，它是一个id为0x029D33E0的type对象的’<strong>call</strong>‘方法的method-wrapper，如果打印<code>print id(Foo)</code>的话，你可以发现它的十六进制结果就是0x029D33E0。这容易理解，而对于method-wrapper，我把它理解为一个方法的封装。查了一些资料，但是没有找到官方的精准答案，这里我猜测对象的创建、函数的执行等过程，在Python中可能是一种C的实现，因此在Python层给出的是一个wrapper，可以让他们的行为像一个Python的函数一样。当然这是我的猜测，如果有知道准确答案的朋友欢迎指导。</p>
<blockquote>
<p><strong>思考</strong>：Class作为一个Callable的类型，对于我们开发中有什么好处吗？</p>
</blockquote>
<p>想象一下工厂方法在C++中的实现，通常需要通过一个函数来封装一个对象的创建过程，而在Python中，我们可以把对象类型存储在一个字典或者列表中，通过映射关系，可以直接生成对象。某种程度上说，这也是一种“反射”机制。具体的代码由于比较简单，此处就不列举了。</p>
<blockquote>
<p><strong>总结</strong>：关于Callable的部分已经聊得差不多了，从我们分析的过程看，我们通常使用dir和print在加上一些分析能力就可以看出Python语言设计上的一些原理和思路，一切皆对象的理念被应用的淋漓尽致，而为了实现其动态特性，Python语言做了很多特殊的设计和方法。</p>
</blockquote>
<p>2016年7月10日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/09/pythonadvance4/" class="article-date">
  	<time datetime="2016-07-09T00:42:42.000Z" itemprop="datePublished">2016-07-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/pythonadvance4/">Python进阶(四)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5-Class-method和Static-method"><a href="#5-Class-method和Static-method" class="headerlink" title="5. Class method和Static method"></a>5. Class method和Static method</h2><p>这部分其实不能算Python的进阶内容了，可以说是基础内容。在初学Python的时候我就有过一些疑惑，<code>@classmethod</code>和<code>@staticmethod</code>修饰的函数看上去似乎没有什么区别，都是通过类来调用（当然对象也可以）。本小节内容稍微看一下两者的区别，首先是class method，因为比较简单，直接看代码例子和结果吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">1 37346800</span><br><span class="line">2 37266616</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们把<code>A.foo</code>打印处理，是一个bound method对象，通过对象a来访问也是一样的，我们学着bound method的方式来分析看，m1和m2的id是不同，在理解了第4小节的内容之后这里就比较容易理解了。</p>
<blockquote>
<p><strong>思考</strong>： Class method是绑定了什么东西的bound method呢？</p>
</blockquote>
<p>通过查看bound method对象的im_self属性就可以看到它所绑定的对象了，我们添加一些代码来分析。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> m1.im_self</span><br><span class="line"><span class="keyword">print</span> m2.im_self</span><br><span class="line"></span><br><span class="line">m3 = a.bar</span><br><span class="line"><span class="keyword">print</span> m3.im_self</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;__main__.A object at 0x02440030&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论</strong>： Class Method是绑定了类对象的bound method。</p>
</blockquote>
<p>需要<strong>额外注意</strong>的是，<code>def foo(self):</code>这里对于class method的定义是不好的，具有一定的误导性，这里的self不再是类的实例对象了，而是一个class对象，因此通常写成<code>def foo(cls):</code>或者<code>def foo(klass)</code>更清晰。</p>
<p>Static method是否也是bound method呢？我们直接来看分析代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">37725360</span></span><br><span class="line"><span class="number">2</span> <span class="number">37725360</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>结论</strong>： Static method就是在类的命名空间中的一个普通函数。</p>
</blockquote>
<h2 id="6-Functors和Operators"><a href="#6-Functors和Operators" class="headerlink" title="6. Functors和Operators"></a>6. Functors和Operators</h2><p>在C++中，重写了()操作符的类，它们实例化的对象就是一个functor，在Python中，重写了<code>__call__</code>方法的类的实例对象是一个functor。这里具体的内容就不再详述了，属于Python中比较基本的内容。<br>类似的，关于操作符（Operators），在Python中也是重载一些对应函数，比如+就是重载<code>__add__</code>函数。这里需要说的是一个性能问题，我们来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">5000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(1, 2)'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(1, 2)'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo("1", "2")'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar("1", "2")'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.689781276848</span></span><br><span class="line"><span class="number">1.40617516723</span></span><br><span class="line"><span class="number">0.806692302726</span></span><br><span class="line"><span class="number">1.4724794197</span></span><br></pre></td></tr></table></figure></p>
<p>原理上，+的操作符是调用<code>__add__</code>方法来进行处理，那为什么直接调用<code>__add__</code>方法反而会慢呢？我们使用dis模块来看一下Python代码翻译成Python虚拟机的指令的区别。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">50</span></span><br><span class="line">dis.dis(bar)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> BINARY_ADD          </span><br><span class="line">              <span class="number">7</span> RETURN_VALUE        </span><br><span class="line">--------------------------------------------------</span><br><span class="line">  <span class="number">7</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_ATTR                <span class="number">0</span> (__add__)</span><br><span class="line">              <span class="number">6</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">9</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure></p>
<p>dis模块的dis方法可以打印出传入函数的虚拟机指令，可以看到foo函数使用+，并没有调用<code>__add__</code>方法，而是用了一个BINARY_ADD指令来直接进行加法。这就是它比直接调用<code>__add__</code>方法快的原因。</p>
<blockquote>
<p><strong>总结</strong>：对于Python的内建类型，操作符比直接调用对应的函数要好，Python可能会使用对应的二进制操作进行优化。</p>
<p><strong>思考</strong>: 对于用户自定义的类型呢，效率哪个更高？</p>
</blockquote>
<p>我们来看例子的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		self._value = v</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._value + v._value</span><br><span class="line">		</span><br><span class="line">n1 = Number(<span class="number">1</span>)</span><br><span class="line">n2 = Number(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> n1 + n2</span><br><span class="line"></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(Number(1), Number(2))'</span>, <span class="string">'from __main__ import foo, Number'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(Number(1), Number(2))'</span>, <span class="string">'from __main__ import bar, Number'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1.34897905469</span></span><br><span class="line"><span class="number">1.26909055996</span></span><br></pre></td></tr></table></figure></p>
<p>看上去，直接调用<code>__add__</code>方法反而更快一些，但是差别整体不大。这是因为+操作符会进行优化尝试，需要额外的时间消耗。不过呢，这点时间差别比较小，而且直接使用类似<code>__add__</code>的方法调用对于代码的可读性维护性会带来一定的困扰，因此大部分情况下，<strong>直接使用操作符会更好</strong>。</p>
<p>2016年7月8日晚于杭州网易大厦</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance3/" class="article-date">
  	<time datetime="2016-07-02T20:55:21.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance3/">Python进阶(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4-Bound-Method和Unbound-Method"><a href="#4-Bound-Method和Unbound-Method" class="headerlink" title="4. Bound Method和Unbound Method"></a>4. Bound Method和Unbound Method</h2><blockquote>
<p><strong>声明</strong>: 本系列文章中的所有内容都是基于Python 2.x版本的，原因是网易绝大部分项目都是在用2.x版本，笔者参与过的项目无论端游还是手游都是基于Python 2.7.x版本进行的开发，因此无论经验还是课程适用性，都是在2.x范围内。在Python 3.x中，unbound method的概念已经被取消了。</p>
</blockquote>
<p>上一小节说了，Bound Method和Unbound Method这部分是我参与大雄的课程中最喜欢的一部分，因为它让我窥探到了Python语言动态特性的一角，也加深了我对于平时在用的一种优化方法的认识。这部分会比较长，我们分几个小节来细说。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>先从代码来看，定义一个简单的类A：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure></p>
<p>很简单，我们来打印一些信息来看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> A.foo		<span class="comment"># &lt;unbound method A.foo&gt;</span></span><br><span class="line"><span class="keyword">print</span> a.foo		<span class="comment"># &lt;bound method A.foo of &lt;__main__.A object at 0x023DE070&gt;&gt;</span></span><br><span class="line"><span class="keyword">print</span> A.foo == a.foo <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a, id(a)	<span class="comment">#&lt;__main__.A object at 0x0235E070&gt; 37085296</span></span><br><span class="line"><span class="keyword">print</span> A.foo.im_self	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> a.foo.im_self	<span class="comment"># &lt;__main__.A object at 0x0241E070&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便对比和理解我把输出的结果放在了对应的print之后，首先输出两个<code>A.foo</code>和<code>a.foo</code>，看到了他们分别是两个对象，一个叫做unbound method，一个叫做bound method，很明显他们是两个不同的对象。这跟我从C++角度来理解Python的方法（Method）就有点不同了——通常静态语言中，面向对象的设计，把方法的定义放在类上，对象通过一定的机制（比如虚函数表等）查找到对应的函数地址来进行调用，那按这样推理，A.foo和a.foo应该是一个东西才对。事实证明Python语言不是这样的。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance3/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance2/" class="article-date">
  	<time datetime="2016-07-02T20:54:20.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance2/">Python进阶(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一部分是关于Python的Callable。在Stackoverflow上有一个专门的问题叫做<a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python">“What is a “callable” in Python”</a>，高票回答中说：</p>
<blockquote>
<p>A callable is anything that can be called.</p>
</blockquote>
<p>这个回答很抽象，大雄从更具体的角度来阐述Callable这个概念——在Python中哪些是callable的？</p>
<ul>
<li><strong>function</strong></li>
<li><strong>closure</strong></li>
<li><strong>bound method</strong></li>
<li><strong>unbound method</strong></li>
<li><strong>class method</strong></li>
<li><strong>static method</strong></li>
<li><strong>functor</strong></li>
<li><strong>operator</strong></li>
<li><strong>class</strong></li>
</ul>
<p>先说答案，很明显，列出的这些都是callable的。这些概念中的大部分我在工作中都有使用，包括比如closure的坑也帮助新同学调试bug的时候看到新入职的同学自己踩到过，但是对于<strong>bound method</strong>和<strong>unbound method</strong>这些概念还不是很清晰。我们也一个个来看。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance2/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/30/pythonadvance1/" class="article-date">
  	<time datetime="2016-06-30T15:01:26.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/pythonadvance1/">Python进阶(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周听了三节Python进阶课程，有十几年的老程序给你讲课传授一门语言的进阶知识，也许这是在大公司才能享受到的福利。虽然接触使用Python也有三四年时间了，但是从课程中还是学习到不少东西，掌握了新技巧的用法，明白了老知识背后的原因。<br>下载了课件，做了笔记，但我还是希望用讲述的方式把它们表现出来，为未来的自己，也给需要的读者。整体以大雄的课程为蓝本，结合我在开发中的一些自己的体会和想法。</p>
<h2 id="1-写操作对于命名空间的影响"><a href="#1-写操作对于命名空间的影响" class="headerlink" title="1. 写操作对于命名空间的影响"></a>1. 写操作对于命名空间的影响</h2><p>首先来看这样一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(processed)</span>:</span></span><br><span class="line">	value = math.pi</span><br><span class="line"></span><br><span class="line">	<span class="comment"># The other programmer add logic here.</span></span><br><span class="line">	<span class="keyword">if</span> processed:</span><br><span class="line">		<span class="keyword">import</span> math</span><br><span class="line">		value = math.sin(value)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">print</span> value</span><br><span class="line">	</span><br><span class="line">foo(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>思考</strong>：你觉得这段代码有没有什么问题，它的运行结果是什么？</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/30/pythonadvance1/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/29/hello-world/" class="article-date">
  	<time datetime="2016-06-28T17:01:43.000Z" itemprop="datePublished">2016-06-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/29/hello-world/">讲述者源始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从大学时代开始，尝试各种形形色色的博客，从网易博客到新浪博客，再到Lofter、简书，甚至写在纸质本子上的手账，断断续续记录，断断续续写作。有些尘封在过往的时光中，布满灰尘，连自己都不再记得内容和样子；有些依然偶尔去填一些文字或者记上几句感慨，不关心过往路人的喜好或者评价。</p>
<p>零散的过去分布在网落的各个角落，每一个都是曾经的开始，现在却已无法把它们找回。但坚持记录了两个多月的手账让我看到了一些不同的东西——有时一天几十个字，有时写满一页，都不过是些当天的总结和思考，或者一些抱怨的话，但沉淀下来，就是逝去的生活。</p>
<p>手账记录给自己，但有些故事想讲给旁人听。于是有了它——<a href="http://www.inarrater.com" target="_blank" rel="external">http://inarrater.com</a>，讲述者。基于Hexo和github搭建的静态独立博客，域名inarrater，我，讲述者。</p>
<p>讲述和记录的不同，在于讲述在乎倾听者，而记录大多只为自己。所以用讲述者命名博客，希望自己放在这里的文字不只是为了取悦自己。它当然可能包含零散的小说，技术的总结，读书的感悟，人生的思考，无论何种形式，务求言之有物。</p>
<p>搭建讲述者，花费大约三个晚上的时间，遇到一些技术问题，包括Hexo的框架，主题的选择，域名的购买，DNS的设置等等。博客还有些简陋，但内容的重要程度大于形式，为了搭建它已经推迟了很多计划，所以可能不会再在这个上面花费太多时间和精力，望见谅。</p>
<p>2016年6月29日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 董夕
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>