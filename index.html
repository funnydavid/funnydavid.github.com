<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Narrater</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Narrater">
<meta property="og:url" content="http://inarrater.com/index.html">
<meta property="og:site_name" content="Narrater">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Narrater">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Narrater" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">董夕</a></h1>
		</hgroup>

		
		<p class="header-subtitle">讲述，而非记录</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Python/" style="font-size: 20px;">Python</a> <a href="/tags/开发/" style="font-size: 20px;">开发</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">程序员，对故事有爱，想要有趣的人生。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">董夕</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">董夕</h1>
			</hgroup>
			
			<p class="header-subtitle">讲述，而非记录</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-pythonadvance6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/pythonadvance6/" class="article-date">
  	<time datetime="2016-07-10T16:06:50.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/pythonadvance6/">Python进阶(六)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讨论完Callable相关的部分之后，我们继续来看一下Class相关的两个东西——Property和super。</p>
<h2 id="9-Property"><a href="#9-Property" class="headerlink" title="9. Property"></a>9. Property</h2><p>这部分其实比较简单，属于Python的基本内容，也是工作中经常用到，比如做属性封装，在属性访问的时候添加一些自己想要做的事情。直接看一个简单的代码例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">		self._a = a</span><br><span class="line">		self._b = b</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_get_a</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._a</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_set_a</span><span class="params">(self, a)</span>:</span></span><br><span class="line">		self._a = a</span><br><span class="line">	a = property(_get_a, _set_a)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_get_b</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._b</span><br><span class="line">	b = property(_get_b)</span><br><span class="line">	</span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a1 = A.a</span><br><span class="line">a2 = A.a</span><br><span class="line">a3 = a.a</span><br><span class="line">a4 = a.a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(a1), id(a2), id(a3), id(a4), id(a._a)</span><br><span class="line"><span class="keyword">print</span> a1, a2, a3, a4</span><br><span class="line"><span class="keyword">print</span> a1.fget, a1.fset</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">39712928</span> <span class="number">39712928</span> <span class="number">39745760</span> <span class="number">39745760</span> <span class="number">39745760</span></span><br><span class="line">&lt;property object at <span class="number">0x025DF8A0</span>&gt; &lt;property object at <span class="number">0x025DF8A0</span>&gt; <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&lt;function _get_a at <span class="number">0x02C677F0</span>&gt; &lt;function _set_a at <span class="number">0x02C677B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们担心会有类似bound method或者unbound method的机制，所以尝试用两个变量来保存A.a和a.a，发现他们的id并不会变化，说明它们在Ptyhon中是一个稳定的对象，而非在需要是动态创建的。当然，A.a和a.a并不是同一个对象，把他们分别输出出来就可以看到，A.a是一个property对象，而a.a直接访问到了a对象身上的_a属性。通过id方法可以看到a3、a4和a._a其实是一同一个对象。<br>关键词property其实是一个class，当访问它的时候，代理对象会用对应的方法进行替换，支持的方法包括fget、fset和fdel。</p>
<h2 id="10-super"><a href="#10-super" class="headerlink" title="10. super"></a>10. super</h2><p>对于super这个关键词的使用其实算是Python的基础知识了，我们从一个简单的例子来探究一下，Python为什么从2.2版本加入这个关键词，它的使用带来我们什么样的便利和困扰？<br>先来看最为简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in A'</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in B'</span></span><br><span class="line">		A.__init__(self)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in C'</span></span><br><span class="line">		super(C, self).__init__()</span><br><span class="line">		</span><br><span class="line">b = B()</span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> super(A, c)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in B</span><br><span class="line">in A</span><br><span class="line">in C</span><br><span class="line">in A</span><br><span class="line">&lt;super: &lt;class 'A'&gt;, &lt;C object&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>结果很简单，无需过多的解释，输出的信息显示了构造的过程，唯一需要指出的是super是一种buildin class。那么它是怎样工作的呢？也就是构造B的时候是如何确定它要调用到的父类方法的呢？<br>在C++中，有虚函数表的结构，用于实现继承中动态多态的特性。在Python中，有<code>__mro__</code>属性来描述继承关系。什么是mro呢？mro是method resolution order，直译是“方法解决顺序”，但是这个不能很好地表达英文原文的含义，简单来说Python用它来解析方法的调用顺序。我们通过具体的例子来看一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in A'</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(B, self).__init__()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">b = B()     <span class="comment"># in A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> B.__mro__     <span class="comment"># (&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>B.__mro__</code>是一个元组，记录了对于B这个类来说的继承关系。在运行时，当调用<code>b.foo</code>方法的时候，会按照mro的顺序去依次查找含有此方法定义的对象或者类，直到找到为止，或者未找到会报错。注意这个过程是在<strong>运行时</strong>的，而非编译时，这也是python方法调用比较慢的原因之一。<br>super关键字也是通过这个数据结构来进行方法调用的，不同的是原理上，在存在的前提下，它会依次调用整个mro结构上的类上对应的方法。</p>
<blockquote>
<p><strong>思考</strong>：<code>__mro__</code>存在在哪里？</p>
</blockquote>
<p>看上去mro属性是一个数据，它似乎应该存储在B的身上，但是我们查看B的<code>__dict__</code>属性的时候发现其中并没有<code>__mro__</code>这个名称。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(B)</span><br><span class="line"><span class="comment"># ['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'foo']</span></span><br></pre></td></tr></table></figure></p>
<p>似乎又有神奇的事情发生了，<code>B.__mro__</code>是如何访问到的呢？我们知道，在没有定义metaclass的情况下，所有的类对象（<strong>类对象，并非类实例对象</strong>）都是一个type对象，那我们来用dir看一下type：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(type)</span><br><span class="line"><span class="comment">#['__abstractmethods__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__', '__dictoffset__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__weakrefoffset__', 'mro']</span></span><br></pre></td></tr></table></figure></p>
<p>Bingo！不但有<code>__mro__</code>，还有一个mro属性。<br>这里关于为什么放在type里，有一个stackoverflow的讨论可以参考下，本文不进行详述了：<br><a href="http://stackoverflow.com/questions/16663514/why-does-mro-not-show-up-in-dirmyclass" target="_blank" rel="external">Why does <strong>mro</strong> not show up in dir(MyClass)?</a></p>
<p>接着我们来回答第一个问题——Python为什么从2.2版本加入这个关键词？<br>在更早的版本中，当调用父类方法的时候，比如上面B继承自A的例子，需要手动调用<code>A.__init__(self)</code>，这样在需要重构A的时候，比如修改名称等，需要把所有继承自A的类中的代码都进行修改，这其实是不合理的一种设定。因此引入了super关键词处理这个过程，同时也为了实现super的功能添加了mro的结构。<br>在单继承结构下，mro可以很好的工作，多继承的情况下会否有什么问题呢？依然看一个简单的例子，C继承自A和B：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'enter A'</span></span><br><span class="line">		<span class="comment"># super(A, self).__init__()</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'level A'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'enter B'</span></span><br><span class="line">		<span class="comment"># super(B, self).__init__()</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'level B'</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in C'</span></span><br><span class="line">		super(C, self).__init__()</span><br><span class="line">		</span><br><span class="line">c = C()</span><br><span class="line">m = c.foo</span><br><span class="line"><span class="keyword">print</span> C.__mro__</span><br><span class="line"><span class="keyword">print</span> m.im_func, A.foo.im_func, B.foo.im_func</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in C</span><br><span class="line">enter A</span><br><span class="line">level A</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;)</span><br><span class="line">&lt;function foo at 0x029478B0&gt; &lt;function foo at 0x029478B0&gt; &lt;function foo at 0x02947830&gt;</span><br></pre></td></tr></table></figure></p>
<p>不太对哦，按照我们想要的结果，应当是通过super可以调用到父类A和父类B中的初始化方法才对！但是结果只调用到了A的，为什么？<br>细心的读者已经发现了，A和B中注释掉了两行super相关的代码，把它们的注释取消掉，输出结果就变成了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in C</span><br><span class="line">enter A</span><br><span class="line">enter B</span><br><span class="line">level B</span><br><span class="line">level A</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;)</span><br><span class="line">&lt;function foo at 0x02A37930&gt; &lt;function foo at 0x02A37930&gt; &lt;function foo at 0x02A378B0&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以调用到了A和B的初始化方法，注意，这里的调用过程是<strong>嵌套</strong>的。具体这是为什么，我这里偷懒，请参考关于super的经典文章：<a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">Python’s super() considered super!</a>，或者参考知乎的问题讨论：<a href="https://www.zhihu.com/question/20040039" target="_blank" rel="external">Python中既然可以直接通过父类名调用父类方法为什么还会存在super函数？</a></p>
<blockquote>
<p><strong>结论</strong>：super基于mro可以处理多重继承的调用关系，按照拓扑结构来进行，同层继承中遵守从左到右的继承顺序。<strong>但是</strong>，要注意所有的父类方法都正确使用super来进行调用，<strong>即使是直接继承自object的对象</strong>！否则可能产生方法调用不到的现象。</p>
</blockquote>
<p>需要额外指出的是，对于参数数目或者类型不同的情况，通过super的调用可能会导致trace，比如下面的例子就会有错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">		super(B, self).__init__(p1)</span><br><span class="line">		</span><br><span class="line">b = B(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(C, self).__init__(<span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">		super(D, self).__init__(p1, p2)</span><br><span class="line">		</span><br><span class="line">d = D(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> D.__mro__</span><br></pre></td></tr></table></figure></p>
<p>在原本A、B和C的继承结构可以正常工作的情况下，加入D，就会导致TypeError，解决的方法只能是按照最多的参数或者dict这种容器来设计函数的参数以兼容多种情况。</p>
<blockquote>
<p><strong>总结</strong>：在Python中，即使引入了super关键字和mro的机制来处理继承的情况，对于复杂的多重继承甚至菱形继承，还会出现很多问题，包括维护上和运行时的问题，因此本质上还是使用类似面向接口编程的方式来从根本上避免这种问题更好。</p>
</blockquote>
<p>PS：关于Python进阶的问题已经写了六篇了，在整理记录的过程中，我发现了一些听课时没有考虑过的新问题，也通过阅读其他的文档掌握新的知识，在简书上也收到了不少喜欢和关注。感谢引导我学习给我们讲课的同事大雄，然后感谢每一个阅读的读者，你有收获或者思考，我们彼此花的时间就都值得了。<br>关于基本的语言特性部分基本就包括上面的1-10个小节的内容，后面的课程内容关于gc和C++绑定等部分的，看时间慢慢整理。</p>
<p>2016年7月11日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/10/pythonadvance5/" class="article-date">
  	<time datetime="2016-07-10T13:03:25.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/pythonadvance5/">Python进阶(五)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="7-Function"><a href="#7-Function" class="headerlink" title="7. Function"></a>7. Function</h2><p>作为Callable部分第一个被提到，但是最后来分析它。原因其实很简单，我们已经发现前面的很多内容，包括bound method也好，static method也好，甚至operators，本质上都是function。<br>那么，如何去探究一个Python的Function的属性呢，阅读过前面内容的读者应该很明白了，通过一些简单的代码加上print就可以看到不少东西了。<br>我们先用dirf来看下一个function对象身上有什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b = <span class="number">10</span>)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(foo)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'func_closure'</span>, <span class="string">'func_code'</span>, <span class="string">'func_defaults'</span>, <span class="string">'func_dict'</span>, <span class="string">'func_doc'</span>, <span class="string">'func_globals'</span>, <span class="string">'func_name'</span>]</span><br></pre></td></tr></table></figure></p>
<p>不管双下划线开头的部分属性，我们只看对外开放的部分，先来看一看func_name属性吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> foo       <span class="comment">#&lt;function foo at 0x0235A2B0&gt;</span></span><br><span class="line">foo.func_name = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">print</span> foo       &lt;function abc at <span class="number">0x0235A2B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>func_name看上只是用来记录信息的一个名称而已，修改它并不会影响函数对象的调用。<br>我们再来看下func_defaults属性，看名称它是和默认值相关。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)			<span class="comment">#11</span></span><br><span class="line"><span class="keyword">print</span> foo.func_defaults		<span class="comment">#(10,)</span></span><br><span class="line">foo.func_defaults = (<span class="number">100</span>, )</span><br><span class="line">foo(<span class="number">1</span>)			<span class="comment">#101</span></span><br></pre></td></tr></table></figure></p>
<p>依然是把输出的结果放在代码行的后面以注释的形式给出，我们看到函数对象的func_defaults属性是一个元组，依次列出了所有默认参数。我们可以通过改变这个属性来改变已经被定义了的函数的默认参数。<br>为了可以看到func_closture的内容，我们构建一个闭包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> x + n</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">	</span><br><span class="line">f = bar(<span class="number">1</span>)</span><br><span class="line">g = bar(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">2</span>)		<span class="comment"># 3</span></span><br><span class="line"><span class="keyword">print</span> g(<span class="string">"def"</span>)	<span class="comment"># defabc</span></span><br><span class="line"><span class="keyword">print</span> foo.func_closure	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> f.func_closure	<span class="comment"># (&lt;cell at 0x029655F0: int object at 0x029378E0&gt;,)</span></span><br><span class="line"><span class="keyword">print</span> g.func_closure	<span class="comment"># (&lt;cell at 0x02A31130: str object at 0x02972AE8&gt;,)</span></span><br></pre></td></tr></table></figure></p>
<p>f和g是两个闭包对象，可以看到foo这个函数对象身上的func_closure属性为None，f和g身上分别是两个cell对象，这部分内容和闭包中讲的部分就契合在了一起。<br>func_code属性我们也来看一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bar.func_code</span><br><span class="line"><span class="keyword">print</span> dir(bar.func_code)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">foo.func_code = bar.func_code</span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出的结果由于比较长，写在了下面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;code object bar at <span class="number">02516</span>C80, file <span class="string">"C:\Users\David-PC\Desktop\Advanced Course on Python 2016\a014.py"</span>, line <span class="number">27</span>&gt;</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__cmp__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>, <span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_lnotab'</span>, <span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，func<em>code是一个code object，它有的属性有很多，基本以co</em>开头，如果有兴趣，可以自己一点点去把他们print出来看，也可以发现很多有趣的东西，这里暂时不进行展开。例子的另外一部分展示了func_code是可以被替换的。</p>
<blockquote>
<p><strong>扩展</strong>：关于code对象，可以阅读<a href="https://late.am/post/2012/03/26/exploring-python-code-objects.html" target="_blank" rel="external">Exploring Python Code Objects</a>，了解怎样通过compile方法来生成code object，以及code类的一些属性。</p>
</blockquote>
<p>关于function中比较重要的几个属性，以表格的形式总结出来。<br>| 属性名称      | 描述   |<br>| ——–      | —–:  |<br>| func_name     | 函数名称 |<br>| func_defaults |   函数的默认值列表   |<br>| func_code     |    函数体的code对象    |<br>| func_globals  |  函数的全局命名空间 |<br>| func_closure  | 函数的cell对象 |<br>看了function的这些属性，对于之前讨论过的hotfix是不是有了更深的了解呢？只需要替换一个函数对象的func_code，func_defaults，func_closure等属性，这个函数的行为就可以被改变了，结合上bound method和unbound method的动态生成的特性，对Python语言的动态性的原理的理解是否有更深入了一步呢？</p>
<h2 id="8-Classes"><a href="#8-Classes" class="headerlink" title="8. Classes"></a>8. Classes</h2><p>关于类，其实有很多可以讨论的内容，从生命周期的角度来看，一个C++类的对象包含如下四个生命周期：</p>
<ol>
<li>内存分配，malloc</li>
<li>调用构造函数初始化对象，A::A()</li>
<li>调用析构函数清理对象，A::~A()</li>
<li>释放内存，free</li>
</ol>
<p>不同的编译器在内存分配或者释放的时候具体使用的函数可能不同，但这四个步骤是都有的，而且在C++中，1和4两个步骤是隐式的，即开发者通常不需要去关心（当然也有可以去操作的方法），它们分别隐含在了构造函数和析构函数当中。<br>对于Python的对象来说，其生命周期包含如下三个部分：</p>
<ol>
<li>内存分配，<code>__new__</code>方法；</li>
<li>调用初始化(initializer)，<code>__init__</code>方法；</li>
<li>调用终结器(finalizer)，<code>__del__</code>方法；</li>
</ol>
<p>对于自定义的类，上述的过程可以通过重载对应的方法来实现对于其过程的控制。可以看到，这里并没有内存释放的过程，也就是说开发者无法主动控制对象所占用过的内存的释放，这一部分是方便开发者不需要进行内存的管理，另外也利于Python语言本身进行对象缓存池的设计与实现。这部分内容在bound method的部分已经看到了缓存池在Python的应用，更多的讨论放在内存管理的部分来进行。</p>
<blockquote>
<p><strong>思考</strong>：Python中如何实现单例模式？是否可以通过重载<code>__new__</code>方法，在每次分配内存的时候返回同一个对象来实现呢？</p>
</blockquote>
<p>答案是否定的，因为Python对于生命周期的控制决定了在<code>__new__</code>方法被调用，内存分配完毕之后会主动调用<code>__init__</code>方法，这样虽然分配的是同一个对象，但是多次<code>__init__</code>方法的调用可能会导致对象的属性被修改，可能会引发意料之外的bug，比如已经被修改过属性又被<code>__init__</code>方法改变等。</p>
<p>说了这些之后，对于Class我们返回Callable的主题，Python中的Class也是一个Callable的对象，调用一个类的结果很简单，就是获得一个类的实例化对象，我们来看一个简单的例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Foo 				<span class="comment"># &lt;class '__main__.Foo'&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo.__call__		<span class="comment"># &lt;method-wrapper '__call__' of type object at 0x029D33E0&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo()				<span class="comment"># &lt;__main__.Foo object at 0x02AAEED0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> func.__call__		<span class="comment"># &lt;method-wrapper '__call__' of function object at 0x029C77F0&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>类Foo是一个class对象，它是可以访问到<code>__call__</code>属性的，它是一个id为0x029D33E0的type对象的’<strong>call</strong>‘方法的method-wrapper，如果打印<code>print id(Foo)</code>的话，你可以发现它的十六进制结果就是0x029D33E0。这容易理解，而对于method-wrapper，我把它理解为一个方法的封装。查了一些资料，但是没有找到官方的精准答案，这里我猜测对象的创建、函数的执行等过程，在Python中可能是一种C的实现，因此在Python层给出的是一个wrapper，可以让他们的行为像一个Python的函数一样。当然这是我的猜测，如果有知道准确答案的朋友欢迎指导。</p>
<blockquote>
<p><strong>思考</strong>：Class作为一个Callable的类型，对于我们开发中有什么好处吗？</p>
</blockquote>
<p>想象一下工厂方法在C++中的实现，通常需要通过一个函数来封装一个对象的创建过程，而在Python中，我们可以把对象类型存储在一个字典或者列表中，通过映射关系，可以直接生成对象。某种程度上说，这也是一种“反射”机制。具体的代码由于比较简单，此处就不列举了。</p>
<blockquote>
<p><strong>总结</strong>：关于Callable的部分已经聊得差不多了，从我们分析的过程看，我们通常使用dir和print在加上一些分析能力就可以看出Python语言设计上的一些原理和思路，一切皆对象的理念被应用的淋漓尽致，而为了实现其动态特性，Python语言做了很多特殊的设计和方法。</p>
</blockquote>
<p>2016年7月10日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/09/pythonadvance4/" class="article-date">
  	<time datetime="2016-07-09T00:42:42.000Z" itemprop="datePublished">2016-07-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/pythonadvance4/">Python进阶(四)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5-Class-method和Static-method"><a href="#5-Class-method和Static-method" class="headerlink" title="5. Class method和Static method"></a>5. Class method和Static method</h2><p>这部分其实不能算Python的进阶内容了，可以说是基础内容。在初学Python的时候我就有过一些疑惑，<code>@classmethod</code>和<code>@staticmethod</code>修饰的函数看上去似乎没有什么区别，都是通过类来调用（当然对象也可以）。本小节内容稍微看一下两者的区别，首先是class method，因为比较简单，直接看代码例子和结果吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">1 37346800</span><br><span class="line">2 37266616</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们把<code>A.foo</code>打印处理，是一个bound method对象，通过对象a来访问也是一样的，我们学着bound method的方式来分析看，m1和m2的id是不同，在理解了第4小节的内容之后这里就比较容易理解了。</p>
<blockquote>
<p><strong>思考</strong>： Class method是绑定了什么东西的bound method呢？</p>
</blockquote>
<p>通过查看bound method对象的im_self属性就可以看到它所绑定的对象了，我们添加一些代码来分析。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> m1.im_self</span><br><span class="line"><span class="keyword">print</span> m2.im_self</span><br><span class="line"></span><br><span class="line">m3 = a.bar</span><br><span class="line"><span class="keyword">print</span> m3.im_self</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;__main__.A object at 0x02440030&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论</strong>： Class Method是绑定了类对象的bound method。</p>
</blockquote>
<p>需要<strong>额外注意</strong>的是，<code>def foo(self):</code>这里对于class method的定义是不好的，具有一定的误导性，这里的self不再是类的实例对象了，而是一个class对象，因此通常写成<code>def foo(cls):</code>或者<code>def foo(klass)</code>更清晰。</p>
<p>Static method是否也是bound method呢？我们直接来看分析代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">37725360</span></span><br><span class="line"><span class="number">2</span> <span class="number">37725360</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>结论</strong>： Static method就是在类的命名空间中的一个普通函数。</p>
</blockquote>
<h2 id="6-Functors和Operators"><a href="#6-Functors和Operators" class="headerlink" title="6. Functors和Operators"></a>6. Functors和Operators</h2><p>在C++中，重写了()操作符的类，它们实例化的对象就是一个functor，在Python中，重写了<code>__call__</code>方法的类的实例对象是一个functor。这里具体的内容就不再详述了，属于Python中比较基本的内容。<br>类似的，关于操作符（Operators），在Python中也是重载一些对应函数，比如+就是重载<code>__add__</code>函数。这里需要说的是一个性能问题，我们来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">5000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(1, 2)'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(1, 2)'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo("1", "2")'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar("1", "2")'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.689781276848</span></span><br><span class="line"><span class="number">1.40617516723</span></span><br><span class="line"><span class="number">0.806692302726</span></span><br><span class="line"><span class="number">1.4724794197</span></span><br></pre></td></tr></table></figure></p>
<p>原理上，+的操作符是调用<code>__add__</code>方法来进行处理，那为什么直接调用<code>__add__</code>方法反而会慢呢？我们使用dis模块来看一下Python代码翻译成Python虚拟机的指令的区别。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">50</span></span><br><span class="line">dis.dis(bar)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> BINARY_ADD          </span><br><span class="line">              <span class="number">7</span> RETURN_VALUE        </span><br><span class="line">--------------------------------------------------</span><br><span class="line">  <span class="number">7</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_ATTR                <span class="number">0</span> (__add__)</span><br><span class="line">              <span class="number">6</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">9</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure></p>
<p>dis模块的dis方法可以打印出传入函数的虚拟机指令，可以看到foo函数使用+，并没有调用<code>__add__</code>方法，而是用了一个BINARY_ADD指令来直接进行加法。这就是它比直接调用<code>__add__</code>方法快的原因。</p>
<blockquote>
<p><strong>总结</strong>：对于Python的内建类型，操作符比直接调用对应的函数要好，Python可能会使用对应的二进制操作进行优化。</p>
<p><strong>思考</strong>: 对于用户自定义的类型呢，效率哪个更高？</p>
</blockquote>
<p>我们来看例子的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		self._value = v</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._value + v._value</span><br><span class="line">		</span><br><span class="line">n1 = Number(<span class="number">1</span>)</span><br><span class="line">n2 = Number(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> n1 + n2</span><br><span class="line"></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(Number(1), Number(2))'</span>, <span class="string">'from __main__ import foo, Number'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(Number(1), Number(2))'</span>, <span class="string">'from __main__ import bar, Number'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1.34897905469</span></span><br><span class="line"><span class="number">1.26909055996</span></span><br></pre></td></tr></table></figure></p>
<p>看上去，直接调用<code>__add__</code>方法反而更快一些，但是差别整体不大。这是因为+操作符会进行优化尝试，需要额外的时间消耗。不过呢，这点时间差别比较小，而且直接使用类似<code>__add__</code>的方法调用对于代码的可读性维护性会带来一定的困扰，因此大部分情况下，<strong>直接使用操作符会更好</strong>。</p>
<p>2016年7月8日晚于杭州网易大厦</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance3/" class="article-date">
  	<time datetime="2016-07-02T20:55:21.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance3/">Python进阶(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4-Bound-Method和Unbound-Method"><a href="#4-Bound-Method和Unbound-Method" class="headerlink" title="4. Bound Method和Unbound Method"></a>4. Bound Method和Unbound Method</h2><blockquote>
<p><strong>声明</strong>: 本系列文章中的所有内容都是基于Python 2.x版本的，原因是网易绝大部分项目都是在用2.x版本，笔者参与过的项目无论端游还是手游都是基于Python 2.7.x版本进行的开发，因此无论经验还是课程适用性，都是在2.x范围内。在Python 3.x中，unbound method的概念已经被取消了。</p>
</blockquote>
<p>上一小节说了，Bound Method和Unbound Method这部分是我参与大雄的课程中最喜欢的一部分，因为它让我窥探到了Python语言动态特性的一角，也加深了我对于平时在用的一种优化方法的认识。这部分会比较长，我们分几个小节来细说。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>先从代码来看，定义一个简单的类A：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure></p>
<p>很简单，我们来打印一些信息来看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> A.foo		<span class="comment"># &lt;unbound method A.foo&gt;</span></span><br><span class="line"><span class="keyword">print</span> a.foo		<span class="comment"># &lt;bound method A.foo of &lt;__main__.A object at 0x023DE070&gt;&gt;</span></span><br><span class="line"><span class="keyword">print</span> A.foo == a.foo <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a, id(a)	<span class="comment">#&lt;__main__.A object at 0x0235E070&gt; 37085296</span></span><br><span class="line"><span class="keyword">print</span> A.foo.im_self	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> a.foo.im_self	<span class="comment"># &lt;__main__.A object at 0x0241E070&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便对比和理解我把输出的结果放在了对应的print之后，首先输出两个<code>A.foo</code>和<code>a.foo</code>，看到了他们分别是两个对象，一个叫做unbound method，一个叫做bound method，很明显他们是两个不同的对象。这跟我从C++角度来理解Python的方法（Method）就有点不同了——通常静态语言中，面向对象的设计，把方法的定义放在类上，对象通过一定的机制（比如虚函数表等）查找到对应的函数地址来进行调用，那按这样推理，A.foo和a.foo应该是一个东西才对。事实证明Python语言不是这样的。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance3/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance2/" class="article-date">
  	<time datetime="2016-07-02T20:54:20.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance2/">Python进阶(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一部分是关于Python的Callable。在Stackoverflow上有一个专门的问题叫做<a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python">“What is a “callable” in Python”</a>，高票回答中说：</p>
<blockquote>
<p>A callable is anything that can be called.</p>
</blockquote>
<p>这个回答很抽象，大雄从更具体的角度来阐述Callable这个概念——在Python中哪些是callable的？</p>
<ul>
<li><strong>function</strong></li>
<li><strong>closure</strong></li>
<li><strong>bound method</strong></li>
<li><strong>unbound method</strong></li>
<li><strong>class method</strong></li>
<li><strong>static method</strong></li>
<li><strong>functor</strong></li>
<li><strong>operator</strong></li>
<li><strong>class</strong></li>
</ul>
<p>先说答案，很明显，列出的这些都是callable的。这些概念中的大部分我在工作中都有使用，包括比如closure的坑也帮助新同学调试bug的时候看到新入职的同学自己踩到过，但是对于<strong>bound method</strong>和<strong>unbound method</strong>这些概念还不是很清晰。我们也一个个来看。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance2/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/30/pythonadvance1/" class="article-date">
  	<time datetime="2016-06-30T15:01:26.000Z" itemprop="datePublished">2016-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/30/pythonadvance1/">Python进阶(一)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周听了三节Python进阶课程，有十几年的老程序给你讲课传授一门语言的进阶知识，也许这是在大公司才能享受到的福利。虽然接触使用Python也有三四年时间了，但是从课程中还是学习到不少东西，掌握了新技巧的用法，明白了老知识背后的原因。<br>下载了课件，做了笔记，但我还是希望用讲述的方式把它们表现出来，为未来的自己，也给需要的读者。整体以大雄的课程为蓝本，结合我在开发中的一些自己的体会和想法。</p>
<h2 id="1-写操作对于命名空间的影响"><a href="#1-写操作对于命名空间的影响" class="headerlink" title="1. 写操作对于命名空间的影响"></a>1. 写操作对于命名空间的影响</h2><p>首先来看这样一段代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(processed)</span>:</span></span><br><span class="line">	value = math.pi</span><br><span class="line"></span><br><span class="line">	<span class="comment"># The other programmer add logic here.</span></span><br><span class="line">	<span class="keyword">if</span> processed:</span><br><span class="line">		<span class="keyword">import</span> math</span><br><span class="line">		value = math.sin(value)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">print</span> value</span><br><span class="line">	</span><br><span class="line">foo(<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>思考</strong>：你觉得这段代码有没有什么问题，它的运行结果是什么？</p>
</blockquote>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/06/30/pythonadvance1/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/29/hello-world/" class="article-date">
  	<time datetime="2016-06-28T17:01:43.000Z" itemprop="datePublished">2016-06-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/29/hello-world/">讲述者源始</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从大学时代开始，尝试各种形形色色的博客，从网易博客到新浪博客，再到Lofter、简书，甚至写在纸质本子上的手账，断断续续记录，断断续续写作。有些尘封在过往的时光中，布满灰尘，连自己都不再记得内容和样子；有些依然偶尔去填一些文字或者记上几句感慨，不关心过往路人的喜好或者评价。</p>
<p>零散的过去分布在网落的各个角落，每一个都是曾经的开始，现在却已无法把它们找回。但坚持记录了两个多月的手账让我看到了一些不同的东西——有时一天几十个字，有时写满一页，都不过是些当天的总结和思考，或者一些抱怨的话，但沉淀下来，就是逝去的生活。</p>
<p>手账记录给自己，但有些故事想讲给旁人听。于是有了它——<a href="http://www.inarrater.com" target="_blank" rel="external">http://inarrater.com</a>，讲述者。基于Hexo和github搭建的静态独立博客，域名inarrater，我，讲述者。</p>
<p>讲述和记录的不同，在于讲述在乎倾听者，而记录大多只为自己。所以用讲述者命名博客，希望自己放在这里的文字不只是为了取悦自己。它当然可能包含零散的小说，技术的总结，读书的感悟，人生的思考，无论何种形式，务求言之有物。</p>
<p>搭建讲述者，花费大约三个晚上的时间，遇到一些技术问题，包括Hexo的框架，主题的选择，域名的购买，DNS的设置等等。博客还有些简陋，但内容的重要程度大于形式，为了搭建它已经推迟了很多计划，所以可能不会再在这个上面花费太多时间和精力，望见谅。</p>
<p>2016年6月29日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 董夕
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>