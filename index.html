<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Narrater</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Narrater">
<meta property="og:url" content="http://inarrater.com/index.html">
<meta property="og:site_name" content="Narrater">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Narrater">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Narrater" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">董夕</a></h1>
		</hgroup>

		
		<p class="header-subtitle">讲述，而非记录</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Lua/" style="font-size: 13.33px;">Lua</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Retargeting/" style="font-size: 10px;">Retargeting</a> <a href="/tags/Unity/" style="font-size: 10px;">Unity</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/开发/" style="font-size: 20px;">开发</a> <a href="/tags/性能优化/" style="font-size: 10px;">性能优化</a> <a href="/tags/总结/" style="font-size: 10px;">总结</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">程序员，对故事有爱，想要有趣的人生。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">董夕</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars3.githubusercontent.com/u/1161707?v=3&amp;u=799cd3cd987f22d4f4ee828fcb756150fb5623b1&amp;s=140" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">董夕</h1>
			</hgroup>
			
			<p class="header-subtitle">讲述，而非记录</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/funnydavid" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/funny-david" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="https://www.douban.com/people/3439529/" title="douban">douban</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-unityretargeting" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/20/unityretargeting/" class="article-date">
  	<time datetime="2017-04-19T16:09:57.000Z" itemprop="datePublished">2017-04-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/20/unityretargeting/">动画重定向技术分析和Unity中的应用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>新的手游项目使用Unity引擎，动画部分要使用<a href="https://docs.unity3d.com/Manual/Retargeting.html" target="_blank" rel="external">重定向技术</a>来实现动画复用。之前在大公司工作的时候对这块了解比较深入，读过Havok引擎在这部分的实现源码，也基于自己的理解在公司自研的手游引擎中实现了一个简化的版本。本文从原理层面分析一下Animation Retargeting技术的实现方式，然后落回到Unity引擎中，记录一下我们使用Retargeting的时候遇到的问题和解决方法。</p>
<h2 id="1-什么是动画重定向"><a href="#1-什么是动画重定向" class="headerlink" title="1. 什么是动画重定向"></a>1. 什么是动画重定向</h2><p>动画重定向，即Animation Retargeting，是一种动画复用的技术，直观上，你可以把它的作用想象成周星驰电影《西游-降魔篇》里的“听话符”——“我做什么，你就跟我做什么”。<br><img src="http://o9hm1ti4o.bkt.clouddn.com/tinghuafu.png" alt="听话符"></p>
<p>这里给出一个非官方的定义：</p>
<blockquote>
<p>Retargeting is just the process of “copying” the animation from one skeleton to the other.</p>
</blockquote>
<p>简单来说，重定向技术就是一种在将动画数据从一个骨架拷贝到另外一个骨架的过程，只是这个所谓的“拷贝”过程，没有Ctrl+C、Ctrl+V这么简单，其实现的方式，也会影响到动画应用到另外一个骨架之后的效果。</p>
<h2 id="2-为什要使用动画重定向"><a href="#2-为什要使用动画重定向" class="headerlink" title="2. 为什要使用动画重定向"></a>2. 为什要使用动画重定向</h2><p>动画重定向技术在很多地方已经得到很广泛的应用，比如目前3A级主机游戏常用的动作捕捉技术就是基于这个原理来实现的——将真实人物 的动作通过图像识别等技术生成动画信息应用到虚拟的角色身上，保存成动画数据。还有Max和Maya这样的建模工具中，也都已经集成了这一技术，用来方便美术把一个动作文件复用到其他骨架上。</p>
<p>那什么样的游戏开发需要这样的技术呢？我们可以假想如果要开发类似《街霸》这样的3D格斗游戏，其中有几十个不同体型姿态各异的角色，战斗过程中会有很多抓技和投技的动作表现，对于这一类型的技能，不同角色的受击动作应该是一致的。</p>
<p>如果使用最常规的制作方法，需要对每一个角色制作攻击动作对应的受击动画，或者需要限制策划设计的受击表现在使用固定姿势、挂接、特效等方式可以实现的范围内。而不甘平庸的策划同学往往需要更加复杂的受击表现，常规的制作方法带来的问题有如下三个方面：</p>
<p><strong>a) 美术工作量较大。</strong> 如果有n个不同角色的骨架，有m个需要特殊表现的技能，那么只考虑受击动画就需要m*n个，这个数量级通常会在几千个动作的级别。美术需要制作、导出这些动画文件，需要非常大的工作量。</p>
<p><strong>b) 动画维护困难。</strong> 想象下，策划设计了一个需要特殊动作表现的技能，美术加班加点制作出了所有英雄的受击动画，第二天黑着眼圈来上班，策划同学满脸讪笑地走过来说——“哎呀，你看，这个受击动作的第15帧有点不自然，力量感不够强，要你不优化一下？”……每一处修改都需要美术手动同步到其他动作文件上，重新调整导出，这一过程太过费时费力。</p>
<p><strong>c) 游戏发布打包文件过大。</strong> 动画文件多必然带来这一问题，尤其是在手游中，包体大小通常是安卓渠道发行的一个需要考虑的重要指标。</p>
<p>而动画重定向技术就是一种时间换空间的思路，在运行时将一套动画根据预计算好的骨骼差异信息，得到目标模型骨架上可以适用的动画数据，就可以生成目标角色的受击动画效果。这种方式既可以减少美术的工作量，又可以增加游戏对策划需求和修改的灵活度，将需要维护和打包的动画数量从m*n这样的平方级别降低到m个。当然，软件工程中“没有银弹”的定律在这里依旧生效，重定向之后的动画可能由于体型差异等问题在某些情况下无法完全满足策划或者美术的要求，这就需要一些额外的方法或者重新制作部分动画来进行弥补，这部分放在后面进行详述。</p>
<h2 id="3-基本原理"><a href="#3-基本原理" class="headerlink" title="3. 基本原理"></a>3. 基本原理</h2><p>写到这里，其实之前有一点没有说明的是动画重定向技术主要是针对骨骼动画的方案，由骨骼来描述动作信息，用蒙皮来表示模型网格与骨骼之间的关系从而得到模型最终的样子。对于这块不熟悉的读者可以自己查阅一下相关的资料。<br><img src="http://o9hm1ti4o.bkt.clouddn.com/skeletonanimation.png" alt="骨骼动画"></p>
<p>动画重定向的过程主要是针对骨骼信息，对于蒙皮过程没有任何影响。而动画信息，可以理解为每一帧中所有骨骼数据信息的集合，更加形象地理解，动画就是每一帧为模型制作一个Pose（姿势），在每帧之间的姿势可以通过差值获得。</p>
<p>为了更加清楚地描述动画重定向地原理，我们截取某一帧的姿势来进行分析——在解决了每一帧的姿势重定向之后，整个动画的重定向也就是在每一帧都进行姿势的重定向即可。</p>
<p>假设有两个模型，他们的骨架分别是A和B，我们拥有A骨架对应的动画数据，想把这个动画数据应用在B骨架上。直接应用是否可以？当A骨架和B骨架完全一样的时候，直接应用是可以的，但通常动画重定向要处理的是骨架不太一样的情况。这些不一样的情况有很多种，比如：<br>a) 骨骼数量不一致；<br>b) 骨骼父子关系不一致；<br>c) 骨骼名称不一致；<br>d) 骨骼本身的长度等数据不一致。</p>
<p>对于前几种不一致情况的处理，我们在基本原理的部分先不进行分析，对于骨骼数量一致、骨骼父子关系也相同这样最为简单的情况下，我们来看一下动画重定向的基本方式。</p>
<p>先明确在这种情况下，直接应用A的动画数据到B上会存在的问题。想象一下，A是一个身高为1.8m左右的大人骨架，而B是一个身高为1.5m左右小孩骨架，A的动画信息记录的骨骼位置（Position）、旋转（Rotation）和缩放（Scale）信息都是针对于大人的，比如经过最终的计算，在Idle动画中的某一帧姿势中，模型空间下A的Head这根骨骼可能在距离地面1.7m这样的位置，而同样的动作让一个小孩B来做，也把Head骨骼放置在1.7m的位置，蒙皮之后的结果会非常奇怪，出现拉伸等问题，因为B的身高整个才是1.5m。</p>
<p>为了解决这个问题，或者说一个正确的动画重定向过程，是基于所谓的参考姿势（Reference Pose）的。通常情况下，会把T-Pose作为参考姿势。引入参考姿势之后，动画数据不再直接应用到目标骨架上，而是把动画姿势与参考姿势的差异应用到目标骨架上。a1是A骨架的参考姿势，b1是B骨架的参考姿势，动画中某一帧的姿势是a2，我们想得到的结果是b2，我们认为，a2与参考姿势a1的差异应当和b2与其对应的参考姿势b1的差异相同，即：</p>
<blockquote>
<p>a2 - a1 = b2 - b1</p>
</blockquote>
<p>我们可以得到计算过程为：</p>
<blockquote>
<p>b2 = a2 - a1 + b2 = a2 + (b1 - a1)</p>
</blockquote>
<p>这其中，a1和b1的数据是在游戏发布时就确定的，因此可以进行预先计算好b1-a1的值。要知道这里的加法和减法要转换为每根骨骼的PRS计算，因此还是有不少CPU消耗的。下图给出了使用一个简单整数代替骨骼的PRS数据来模拟动画重定向的计算过程。</p>
<p><img src="http://o9hm1ti4o.bkt.clouddn.com/animationretargeting1.png" alt="简化版本的动画重定向原理"></p>
<p>从上图可以看出，在Setup阶段，可以计算出b1-a1的值，然后运行时只需要根据动画数据这个diff值就可以得到最终想要的动画效果。这里需要说明的是，在Havok引擎的实现中，会根据a1和b1两个参考姿势中每根骨骼相对于父骨骼的Position计算出骨骼的长度，比如a1中Head骨骼的长度为1.0，b1中Head骨骼的长度为1.5，计算diff的结果时会把这两个值的比例应用到scale部分，即会给scale * 1.5，来保证最终映射出来骨骼位置的合理性。这部分的实现太过细节，其实只需要做这部分实现的人理解即可，有兴趣的朋友可以留言讨论。</p>
<p>在引擎实现方面，Havok引擎使用了单独的mapping文件来存储b1-a1的数据，并且这部分数据具有一定的可定制性；在我自己后来的实现中，采用的方式是加载模型文件时检查该模型是否需要动画重定向，如果需要则计算一份对应的diff信息放在内存中。两种实现方案的区别不大，只是时间和空间的互换，后者是在需求比较确定，减少美术工作量的考量下选择的实现方式。</p>
<p>总之，基于参考姿势的动画重定向计算，不但可以保证大部分情况下可以有良好的动画效果，而且可以保留目标骨架的一些基本姿势特征，比如驼背、八字脚等，应用得到的话是可以让重定向之后的动画也有这些特种。</p>
<h2 id="4-骨骼映射"><a href="#4-骨骼映射" class="headerlink" title="4. 骨骼映射"></a>4. 骨骼映射</h2><p>前面的基本原理只解决了骨骼长度等数据不一致的情况下的动画重定向问题，在骨骼数量、名称甚至父子关系等都不一致的情况下，该如何处理呢？</p>
<p>对于手游应用者来说，答案很简单——尽量不要出现上述的这些情况。虽然有各种技术方案可以一定程度上处理和解决上述问题，但目前工程方面并没有非常完美的效果，而且可能在性能、制作流程复杂度上导致一些问题。</p>
<blockquote>
<p>应用动画重定向技术的原则应当是——在项目初期，做好技术预研，确定使用方法，制定从骨骼结构到骨骼名称等相关的美术规范。在中后期引入这一技术的应用，在美术制作不规范的情况下，可能会有较大的额外工作量。</p>
</blockquote>
<p>这里，针对不同的问题，给出一些解决方案的思路，某些技术细节实现不进行详细的说明。</p>
<h3 id="4-1-骨骼名称不一致"><a href="#4-1-骨骼名称不一致" class="headerlink" title="4.1 骨骼名称不一致"></a>4.1 骨骼名称不一致</h3><p>在项目开发中，处于进度的考虑，往往会把不同角色模型和动画的制作外包给不同的外包商，他们对于骨骼的命名可能会不同，比如常见的Biped Head和Bip001 Head。对于CS骨骼，由于在3DS Max中通常美术只会添加不同的前缀，因此可以通过去除前缀的方式进行模糊匹配来做骨骼映射；Unity的做法细节不清楚，但是感觉会根据整个骨架的父子关系和结构来进行映射关系的计算；而对于Bone骨骼，在没有预先定义好类似最大化骨骼这样规范的情况下，非常难通过程序来判断映射关系，可以提供可视化编辑的功能来让美术自己定义他们之间的映射关系。</p>
<h3 id="4-2-骨骼数量不一致"><a href="#4-2-骨骼数量不一致" class="headerlink" title="4.2 骨骼数量不一致"></a>4.2 骨骼数量不一致</h3><p>我们之前讨论的映射关系，都是一根骨骼对应一根骨骼的简单映射方式。在骨骼数量不一致的又可以分为两种情况来讨论：</p>
<ol>
<li>在非CS骨骼或者不重要的部分存在多余的骨骼。如果动画文件的骨架中存在多余骨骼，通常的做法是把这些骨骼忽略掉，而如果目标骨架上存在多余的骨骼，即有些骨骼原始动画中并不存在，这其实没有办法为他生成动画，只需要保证其保留在原始姿势的local space当中，即让其跟着父骨骼移动。比如身上的飘带，如果原始动画中没有，在不使用布料系统等物理方案的情况下，只能让其按照参考姿势中的样子，“僵硬”地跟随角色移动。</li>
<li><p>在重要的位置存在骨骼不一致。一个常见的例子是胸部的脊柱，不同的角色可能脊柱骨骼数量不同，从2根到4、5根都很常见。这种情况下，简单的一根骨骼映射到一根骨骼就无法做到很好的效果，如下图所示（使用Havok文档中的例子）：</p>
<p><img src="http://o9hm1ti4o.bkt.clouddn.com/chainmapping1.png" alt="链式映射1"><br>我们想让蓝色小人变到黄色小人当前的姿势，蓝色小人胸部只有一根骨骼，而黄色小人有5根，那么让这一根骨骼使用黄色小人那5根骨骼中的任何一根结果都不理想，可能会出现如下图所示的这种结果：<br><img src="http://o9hm1ti4o.bkt.clouddn.com/chainmapping2.png" alt="链式映射2"><br>这种结果最后渲染出来可能是一个头向前倾斜，但是背依然挺直的角色，它的脖子处的蒙皮被拉得很长。这不是我们想要的效果，如果使用链式映射，可以做到如下图所示的这种较好的结果：<br><img src="http://o9hm1ti4o.bkt.clouddn.com/chainmapping3.png" alt="链式映射3"><br>注意，这里同时修复了头顶上的两根骨骼没有跟随父骨骼移动的问题。</p>
</li>
</ol>
<p>链式映射要做的就是将多根骨骼组成的骨链A和另外一个骨骼中多根骨骼组成的骨链B进行映射，做到整条B骨链的样子和A骨链的样子相近。<br>那么链式映射的基本原理就是：<strong>首先对齐起始链骨骼，然后再保持骨链原有样子的条件下，尽量对齐他们的结束骨骼。</strong>下图给出了一个简单的示例：</p>
<p> <img src="http://o9hm1ti4o.bkt.clouddn.com/chainmapping4.png" alt="链式映射原理1"><br> 上图把两根骨骼形成的骨骼链接映射到四根骨骼形成的姿势上面。<br> <img src="http://o9hm1ti4o.bkt.clouddn.com/chainmapping5.png" alt="链式映射原理2"><br> 上图把四根骨骼形成的骨骼链接映射到两根骨骼形成的姿势上面。<br>那么如何对齐结束骨骼呢？这里只简单描述Havok引擎中的计算方法，首先算出从骨链的开始骨骼到结束骨骼的向量，比如A1，B1，然后将这两个向量规范化，计算可以将B1转到A1最小旋转，这个旋转使用四元数表示，描述了一个和两个向量都垂直的轴外加一个旋转角度Theta值。这个四元数的计算过程可以使用向量的点积、叉积和半角正玄公式、二倍角正玄公式得到，避免了三角函数计算这种很耗的计算过程。下图给出了一个简单的计算过程，可以看出其使用向量计算来进行效率上的优化。<br><img src="http://o9hm1ti4o.bkt.clouddn.com/chainmapping6.png" alt="简化的旋转计算过程"></p>
<h3 id="4-3-骨骼父子关系不一致"><a href="#4-3-骨骼父子关系不一致" class="headerlink" title="4.3 骨骼父子关系不一致"></a>4.3 骨骼父子关系不一致</h3><p>当两套骨骼的父子关系都不一致的情况下，其实很难得到正确的映射，简单的不一致可能可以容忍，但是可以想象，把一个人形骨骼的动画映射给四足动物甚至蜘蛛这样的八脚动物，是一件非常难做的事情。</p>
<p>也因为这样的原因，目前大范围应用的动画重定向，基本还是在人形骨骼上，当然，用相同的算法，把四足的战马动画映射到不同的体型的战马上，也是可以的，基本的原则是骨架尽量具有更多的相似性，重定向的效果也就会更好。</p>
<h2 id="5-Unity引擎中的应用"><a href="#5-Unity引擎中的应用" class="headerlink" title="5. Unity引擎中的应用"></a>5. Unity引擎中的应用</h2><p>在了解了基本原理之后，我们来看一下动画重定向技术在工程中的应用。笔者之前使用Havok引擎和实现自研引擎中的相应功能有较多的应用经验，但是Unity引擎还是摸索了一下才找到正确的使用方法，<a href="https://docs.unity3d.com/Manual/Retargeting.html" target="_blank" rel="external">官方文档</a>给出了一个简单的应用过程和效果截图，但这个文档讲述的过程比较简单，一些注意事项也没有说得很清楚。</p>
<h3 id="5-1-基本使用方法"><a href="#5-1-基本使用方法" class="headerlink" title="5.1 基本使用方法"></a>5.1 基本使用方法</h3><p>首先，Unity引擎中动画重定向的实现不是一个直观的方法，而是封装在了Humanoid类型的动画系统里面，也就是必须是人形的骨架、使用Humanoid才可以使用它。Unity没有像前文描述的基本原理那样去定义两套骨架之间的映射关系，而是自己在内部定义一套骨架模板，所有的Avatar骨骼都必须映射到这套模板上才可以由同一个Animator来驱动产生Retargeting之后的动画效果。<br><img src="http://o9hm1ti4o.bkt.clouddn.com/unityretargeting2.png" alt="Unity中的骨架截图"><br>在导入一个模型文件之后，要在这里设置每根骨骼的映射关系，这个映射关系默认会自动建立一套，可以根据需要进行调整，也可以保存和导入配置好的映射关系。</p>
<p>预览一个重定向之后的动画的效果我没找到非常方便的办法，只能把模型放到Scene中，设置同一个Animator来观察，在动画文件的预览窗口，如果拖拽另外一个模型文件到其中，并不能预览到正确的效果，这跟我之前预想的不太一样。这里简单说明一下整个设置过程，假设我们想让一个female的模型复用一个male的动画：<br>a) 导入male的模型，设置动画类型为Humanoid，设置好Avatar上的骨骼映射关系；<br>b) 导入male的动画文件，设置其类型为Humanoid，讲其Avatar设置为male的avatar；<br>c) 使用male的动画制作一个Animator；<br>d) 导入female的模型文件，设置动画类型为Humanoid，同样设置好Avatar上的骨骼映射关系；<br>e) 可以拖拽一个模型文件到Scene中，然后把它的Animator设置为之前male的动画制作的Animator，即可看到Retargeting之后的效果了。</p>
<p>这一过程比较简单，Unity引擎为用户隐藏了非常多的实现细节，让用户在进行尽量少的配置的情况下使用动画重定向功能。</p>
<h3 id="5-2-遇到的问题记录"><a href="#5-2-遇到的问题记录" class="headerlink" title="5.2 遇到的问题记录"></a>5.2 遇到的问题记录</h3><p>在使用过程中，我们遇到了一些问题。<br>a) 第一个是角色的武器或者飘带在使用Humanoid类型的动画系统之后不会移动了，或者移动的位置有了很大的偏差。这时候可以在动画文件的属性设置里，查看Mask下的Transform选项，里面可能存在没有被勾选的骨骼。<br><img src="http://o9hm1ti4o.bkt.clouddn.com/unityretargeting3.png" alt="Unity动画设置"><br>我们目前的做法是把Transform下的所有骨骼对象都勾选上。</p>
<p>b) 第二个是角色的武器在动作中出现了乱飘的问题，与手部无法紧密地绑定在一起。这是由于我们最初为了方便美术制作武器的动作，把其父骨骼设置给了盆骨这样一根相对稳定的骨骼，但是经过Retargeting计算之后，由于角色身材不同产生了一些偏差导致了这一问题。最终我们还是把武器骨骼的父骨骼设置为手部的骨骼，才解决了这一问题。</p>
<p>c) 某些角色在重定向之后的动画中表现为脚不贴地，和地面之间有缝隙，原始动画中没有这一问题。如果你理解了动画重定向的原理，那么当原始动画没有问题，而重定向之后的动画存在问题，有两种可能——一种是重定向算法存在问题，另外一种是参考姿势存在问题。我们在没有代码授权的前提下无法查看和修改Unity引擎的重定向实现代码，而且Retargeting功能已经发布了这么久，理论上大部分的Bug都应该已经修复了。。。在Avatar的Configuration界面中，除了设置骨骼的映射关系之外，还可以设置T-Pos的姿势，这里我们可以对参考姿势做微调，如下图所示：<br><img src="http://o9hm1ti4o.bkt.clouddn.com/unityretargeting4.png" alt="Unity中调整参考姿势"></p>
<p>注意，Unity定义了一个基本的T-Pos姿势范围，当调整的结果超出范围的时候，会出现红色的提示字样。我们的问题是目标角色的脚步骨骼在参考姿势中没有贴地，导致了重定向之后的问题。当你发现重定向之后的动画有些骨骼的姿势很奇怪，或者想让你的目标角色有一些自己的特有个性(比如外八字脚之类的。。。)的时候，可以在这个界面进行调整。</p>
<h3 id="5-3-性能消耗"><a href="#5-3-性能消耗" class="headerlink" title="5.3 性能消耗"></a>5.3 性能消耗</h3><p>通过前面的原理分析可以看出，即使在有预计算的情况下，与普通的动画计算，Retargeting的过程还是有一定的CPU消耗的，但是这与通常会造成CPU瓶颈的蒙皮、渲染指令提交等相比，其实消耗并不算大。由于Unity与Retargeting相关的还制作了肌肉控制的功能，我担心这部分会有额外的性能消耗，还专门拜托朋友帮忙询问了Unity大中华区的技术人员，得到的答复是——Humanoid形式的动画系统相对于Generic形式的动画系统虽然有一部分额外的性能消耗，但是Unity内部做了比较好的优化，差别不是很大，因此可以放心使用。我们由于必须使用Retargeting的功能，因此也没有对几套动画系统进行非常详尽的性能对照测试，但从以往游戏开发的经验来看，动画重定向这块通常不会在后期的性能Profile过程中被揪出来要求优化。</p>
<p>总是，虽然动画重定向这套东西已经很熟悉了，但是在Unity中的应用，我们还是摸索的新兵，目前也只是项目的初期，遇到的问题不是很多，如果有朋友有相关的经验可以介绍和分享，还望不吝赐教。</p>
<h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h2><p>如果你去搜Animation Retargeting相关的论文，会发现学术界有很多更加深入的研究，但是很多算法都不适用于当前的游戏开发。而对于差别非常大的骨架，其实也没有必要非要去用重定向的技术，可能美术单独制作动画资源效果会更好。<br>在之前搜集资料的过程中，读到一篇关于《spore》游戏的论文，觉得比较有意思，<a href="http://slim.chrishecker.com/images/c/cb/Sporeanim-siggraph08.pdf" target="_blank" rel="external">《Real-time Motion Retargeting to Highly Varied User-Created Morphologies》</a>。有兴趣的可以去读一下，《孢子》这款游戏使用的实时动画系统中就有Animation Retargeting技术的应用，结合IK（反向运动学）技术，实现了游戏中自定制角色的动画表现，效果非常不错，玩过的朋友可能会有印象。</p>
<h2 id="7-结语"><a href="#7-结语" class="headerlink" title="7. 结语"></a>7. 结语</h2><p>动画重定向系统就像很多的游戏引擎组件一样，是一个可能从外部看上去似乎很深奥复杂的功能，但是深入其实现原理，却发现其实非常简单。然而，要把这样一个功能封装成一个易用性很强的引擎模块，让用户可以在不理解原理的情况下去轻松地使用它，却又需要解决很多实际问题，开发各种编辑工具。把一项技术，应用到实际的游戏开发中，就需要这样一个由难入易，再由易到难的过程，这也是做科学研究与做实际工程的区别之一吧。</p>
<p>希望本文可以给需要用到动画重定向技术的朋友以帮助，也欢迎更多的朋友进行讨论和分享。对于游戏开发这样一项工作来说，永远都有学习不完的知识和技术，而技术的积累和沉淀，是把游戏做得更好的有力保障</p>
<p>2017年2月2日，于山东菏泽家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Retargeting/">Retargeting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unitydev4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/04/20/unitydev4/" class="article-date">
  	<time datetime="2017-04-19T16:08:40.000Z" itemprop="datePublished">2017-04-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/20/unitydev4/">Unity手游开发札记——ToLua#集成内存泄露检查和性能检测工具</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#0. 前言<br>有段时间没有写博客了，主要原因是事情有点多，一件接着一件，没有太多整理总结的机会。游戏开发逐渐进入铺量制作的忙碌阶段，趣味性没那么多，新鲜感也少了，虽然还是有很多可供记录的点，但大多比较琐碎，难成系统，又或者可能暂时没有结果，不便于分享。<br>这几天花了一些时间在Lua层的内存检查和性能优化与检查方面，对比并尝试集成了一些方案，也踩了一些坑，整理记录在这里，给需要的同学提供参考。</p>
<p>#1. ToLua#的编译<br>之前的博客有提到过，我们使用的是ToLua#作为Unity引擎和Lua之间的桥接工具，本文记录的集成工具都是在C层进行的，因此要编译自己的ToLua#。<br>ToLua#的源码地址是：<a href="https://github.com/topameng/tolua_runtime" target="_blank" rel="external">https://github.com/topameng/tolua_runtime</a>，编译流程可以参考其wiki文档，不过这部分的过程记录的不太详细，本部分基于wiki文档和自己在Windows以及Mac OS上的编译过程进行一些整理，记录整个过程和遇到的问题如下：</p>
<p>1) 安装msys2-x86_64-20161025.exe工具，Web地址：<a href="http://msys2.github.io/。" target="_blank" rel="external">http://msys2.github.io/。</a></p>
<p>2) 为msys2安装gcc，由于原始的下载地址我本地下载非常慢而且出错，建议添加国内的镜像地址：<br>    编辑 /etc/pacman.d/mirrorlist.mingw32 ，在文件开头添加：Server = <a href="http://mirrors.ustc.edu.cn/msys2/REPOS/MINGW/i686" target="_blank" rel="external">http://mirrors.ustc.edu.cn/msys2/REPOS/MINGW/i686</a><br>    编辑 /etc/pacman.d/mirrorlist.mingw64 ，在文件开头添加：<br>    Server = <a href="http://mirrors.ustc.edu.cn/msys2/REPOS/MINGW/x86_64" target="_blank" rel="external">http://mirrors.ustc.edu.cn/msys2/REPOS/MINGW/x86_64</a><br>    编辑 /etc/pacman.d/mirrorlist.msys ，在文件开头添加：<br>    Server = <a href="http://mirrors.ustc.edu.cn/msys2/REPOS/MSYS2/$arch" target="_blank" rel="external">http://mirrors.ustc.edu.cn/msys2/REPOS/MSYS2/$arch</a><br>    然后执行 pacman -Sy 刷新软件包数据即可。</p>
<p>3) 打开mingw的控制台，输入如下命令进行gcc相关工具的安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pacman -S mingw-w64-i686-gcc </span><br><span class="line">pacman -S mingw-w64-x86_64-gcc </span><br><span class="line">pacman -S mingw-w64-i686-make </span><br><span class="line">pacman -S mingw-w64-x86_64-make</span><br><span class="line">pacman -S make</span><br></pre></td></tr></table></figure></p>
<p>4) 安装完毕之后，执行tolua_runtime下的对应sh文件进行编译。</p>
<p>5) 编译Android版本需要安装Android SDK，下载Android NDK r10e，并配置Android NDK r10e的目录到PATH环境变量中，配置ANDROID_NDK_PATH环境变量。需要注意几个配置：<br>sh文件里的NDKABI变量，定义了NDK的版本，在msys64\etc\profiles里设置环境变量。</p>
<p>6) 如果你使用的MinGW-w64 Win64 Shell来编译32位版本的时候会报找不到dll的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: skipping incompatible</span><br><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/lib/libm.a when searching for -lm</span><br><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: skipping incompatible</span><br><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/lib\libm.a when searching for -lm</span><br><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: skipping incompatible</span><br><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/lib/libm.a when searching for -lm</span><br><span class="line">F:/msys64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/6.2.0/../../../../x86_64-w64-mingw32/bin/ld.exe: cannot find -lm</span><br></pre></td></tr></table></figure>
<p>我纠结了半天，按照路径检查发现它用的还是64位的库，在msys64下发现有两个exe，一个叫做mingw64.exe，一个叫做mingw32.exe，使用32位的那个来编译对应的32版本就可以正常编译了。</p>
<p>7) iOS的编译脚本里设置了  ISDKVER=iPhoneOS10.2.sdk，这里要跟随SDK的版本升级进行更新，否则LuaJit就编译不过，报错信息为”string.h”文件找不到。</p>
<p>这样，使用不同的编译脚本就可以编译出对应平台的ToLua.dll文件了，拷贝文件覆盖之前Unity的Plugins目录下对应平台的dll文件即可实现ToLua#的更新。</p>
<blockquote>
<p>注意： 在覆盖的时候要关闭对应工程的Unity进程，否则会提示dll被占用无法覆盖。</p>
</blockquote>
<p>#2. 内存检查工具<br>Unity引擎中有自己的内存检查工具，但是无法查看集成的Lua部分的内存情况。Lua的内存管理由Lua虚拟机负责，Lua 5.1版本的垃圾回收使用的是<strong>双白色标记清除（Mark-sweep）算法</strong>，5.2版本引入了<strong>分代</strong>的策略，具体的实现原理可以参考Lua的源代码。从根本上说，由于有垃圾回收功能的存在，即使存在循环引用的情况，也可以在GC的过程中对不再使用的内存进行释放，不存在严格意义上的“内存泄露”，然而，在游戏运行过程中，无论是C#层的频繁GC还是Lua层的频繁GC，都会导致卡顿的问题，因此要尽量减少内存的无谓分配，从而减少GC的执行频率。当然，由于开发过程中存在C#和Lua的互相引用，可能会出现由于释放过程存在问题导致C#和Lua的对象互相引用然后都GC不掉的情况，这个可能产生更加严重的内存问题。因此，我们需要的内存检查工具最少应当可以针对上述这两种情况进行检查。</p>
<p>通常进行内存排查的原理比较相似，大都是基于两份内存快照之间的差异来进行人工的对比和分析，对于Lua 5.1来说，大部分的资源都是在_G这样一个变量，因此一次常见的思路是从这个_G开始来遍历出所有的Lua对象，当然，如果不想遗漏数据，更加好的遍历起始应当是从<code>debug.getregistry()</code>开始。编写的代码不太复杂，逐一处理好metatable等相关的内容即可，我尝试了git上一个在Lua层的工具：<a href="https://github.com/radiotail/lua_memleak" target="_blank" rel="external">lua_memkeak</a>，有一些问题，原因是我们自己在Lua层Hook了_G的访问机制来避免不小心写出的全局变量。<em>（多说几句，在Lua中不声明local的变量都会作为全局变量，或者更严格地说，函数中的变量在不声明local的情况下，会被放在函数的env中，只是默认所有函数的env都是_G，所以才造成了不声明local的变量会被放置在_G中的现象。不经意的全局变量可能会导致意料之外的数据修改从而产生难以排查的bug，同事导致部分内存无法被正确地释放，因此我们项目中Lua的所有全局变量必须由一个函数来进行声明。）</em></p>
<p>因此我更倾向于找一个C层的实现，云风作为Lua的倡导者，在他的博客中提供了一个Lua内存分析工具：<a href="http://blog.codingnow.com/2012/12/lua_snapshot.html" target="_blank" rel="external">Snapshot</a>，对应的Git地址在<a href="https://github.com/cloudwu/lua-snapshot" target="_blank" rel="external">这里</a>。集成到ToLua#中的过程也比较简单，把snapshot.c文件拷贝到ToLua_Runtime目录下，修改一下build脚本，将snapshot.c加入到编译代码中。由于原始的snapshot.c文件目标是编译为dll供Lua虚拟机调用，这里为了方便ToLua#使用，修改了一下最后的接口导出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static const struct luaL_Reg snapshot_funcs[] = &#123;</span><br><span class="line">	&#123; "snapshot",	b_snapshot &#125;,</span><br><span class="line">	&#123; NULL, NULL &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LUALIB_API int luaopen_snapshot(lua_State *L) &#123;</span><br><span class="line">	luaL_checkversion(L);</span><br><span class="line">	#if LUA_VERSION_NUM &lt; 502</span><br><span class="line">		luaL_register(L, "snapshot", snapshot_funcs);</span><br><span class="line">	#else</span><br><span class="line">		luaL_newlib(L, snapshot_funcs);</span><br><span class="line">	#endif</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照第一步重新编译ToLua#的dll文件，更新之后，添加对应导出的C#接口，然后在Lua代码中仿照例子编写一个初步的内存查看函数：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Lua内存记录功能</span></span><br><span class="line"><span class="keyword">local</span> preLuaSnapshot = <span class="keyword">nil</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">snapshotLuaMemory</span><span class="params">(sender, menu, value)</span></span></span><br><span class="line">    <span class="comment">-- 首先统计Lua内存占用的情况</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"GC前, Lua内存为:"</span>, <span class="built_in">collectgarbage</span>(<span class="string">"count"</span>))</span><br><span class="line">    <span class="comment">-- collectgarbage()</span></span><br><span class="line">    <span class="comment">-- print("GC后, Lua内存为:", collectgarbage("count"))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> snapshot = <span class="built_in">require</span> <span class="string">"snapshot"</span></span><br><span class="line">    <span class="keyword">local</span> curLuaSnapshot = snapshot.snapshot()</span><br><span class="line">    <span class="keyword">local</span> ret = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> preLuaSnapshot ~= <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(curLuaSnapshot) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> preLuaSnapshot[k] == <span class="keyword">nil</span> <span class="keyword">then</span></span><br><span class="line">                count = count + <span class="number">1</span></span><br><span class="line">                ret[k] = v</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(ret) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(k)</span><br><span class="line">        <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"Lua snapshot diff object count is "</span> .. count)</span><br><span class="line">    preLuaSnapshot = curLuaSnapshot</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>使用方法非常简单，制作了一个按钮，触发上述的函数，点击一次会做一个内存快照记录在preLuaSnapShot中，过一段时间，再点击一次按钮，就会在控制台输出内存的diff情况。我们主要针对两块内容进行了初步检查：</p>
<ol>
<li>角色在场景内只做移动等简单操作，查看是否有网络、游戏简单的tick逻辑导致的内存分配。这种情况下更多是不进行手动GC，着重检查不必要的内存分配。</li>
<li>进出战斗之后查看前后快照的diff，检查是否有内存泄露的情况。这种情况下会进行一次手动GC，来回收那些战斗中的临时数据，着重检查由于各种引用关系导致无法被释放的内存对象。</li>
</ol>
<p>我们初步发现了之前代码中的一些问题，包括逻辑代码中可以优化的table创建过程，角色移动过程中不断的回调用的Slot对象创建，ToLua#中协程实现的时候每次wait都会创建一个Timer对象等问题，并逐一进行了修复。</p>
<blockquote>
<p>注意：在使用云风这个Snapshot工具的时候，它好用的地方是可以查看到对象的类型、变量名称和文件行数，但是可能由于某些对象引用在ToLua#内部或者C#层，抑或是我们自己编写的Lua Class机制，导致一些条目无法像云风博客中说的看到那么多细致的内容，只能看到变量名称和类型，通过全局搜索来判定对象被引用的位置。时间关系没有去查看源代码进行优化，之后有时间可以再仔细看下，如果有朋友知道如何解决也希望不吝赐教~</p>
</blockquote>
<p>#3. Profiler的集成</p>
<p>由于我们放置了大量的逻辑在Lua层，因此也需要对Lua的部分进行Profiler来定位可以进行优化的点。由于内存部分使用了云风的Snapshot，因此自然想看看云风的git上是否有Profiler的工具，果然很快找到了——<a href="https://github.com/cloudwu/luaprofiler" target="_blank" rel="external">LuaProfiler</a>。结构也很简单，就一个profiler.c文件需要集成，因此很开心地下载下来尝试集成到游戏中，但是编译的时候各种错误。</p>
<p>仔细看了一下代码，原来用到的很多函数都是Lua 5.2和Lua 5.3版本之后才有的函数，尝试翻找snapshot.c中的代码进行一些5.1版本中的实现，花费了半天时间编译通过了但是试用了下会Crash。对于Lua的代码部分不是非常熟悉，因此觉得再在这个地方花费时间可能是个无底洞，因此又想去找找别的方法。</p>
<p>Lua-users上有专门的<a href="http://lua-users.org/wiki/ProfilingLuaCode" target="_blank" rel="external">Profiling Lua Code</a>专题，第一个是<a href="http://luaprofiler.luaforge.net/" target="_blank" rel="external">LuaProfiler</a>，看了下是支持5.1版本的，但是git上面上次更新是08年的事情了。。。看着有点虚，又搜罗了一圈，其他基于Lua层自己做Profiler的工具感觉对于Lua的运行可能会有比较大的性能影响，因此不太想去尝试。最后还是觉得先试试这个接近10年前的产品。</p>
<p>集成的过程还算顺利，以win64为例，只需要添加如下部分在sh文件中即可：<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">luaprofiler/stack.c \</span><br><span class="line">luaprofiler/clocks.c \</span><br><span class="line">luaprofiler/function_meter.c \</span><br><span class="line">luaprofiler/core_profiler.c \</span><br><span class="line">luaprofiler/lua50_profiler.c \</span><br></pre></td></tr></table></figure></p>
<p>编译也较为顺利，但是一旦在游戏中开启之后，ToLua#就会一直报错。对于Lua调用C#的接口，都会报错在这个地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void CheckArgsCount(IntPtr L, int count)</span><br><span class="line">&#123;</span><br><span class="line">    int c = LuaDLL.lua_gettop(L);</span><br><span class="line"></span><br><span class="line">    if (c != count)</span><br><span class="line">    &#123;</span><br><span class="line">        throw new LuaException(string.Format(&quot;no overload for method takes &apos;&#123;0&#125;&apos; arguments&quot;, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加断点看了下，这里Lua虚拟机的堆栈中的数据c的值比期望的参数个数count大1。利用一个接口查看了下具体的参数类型和数据，前面的都正确，只是最后多一个而已。一开始的想法是LuaProfiler底层的代码为了方便记录数据，在每次函数调用的地方都添加了一个变量来进行数据存储。于是我想只能通过修改ToLua#的生成代码，让之前严格的参数个数必须相等的判断修改为大于等于就通过的判定，这样可以避免误报LuaException，但是仔细思考之后，觉得这样修改太过于麻烦，让ToLua#生成的代码可能不够严谨，于是想从C层看看有没有修改的可能。</p>
<p>其实，无论是云风的方式还是这个LuaProfiler，抑或是其他的基于Lua层的性能检查工具，其根本原理是基于lua_sethook这样一个功能。</p>
<blockquote>
<p>lua_sethook</p>
<p>int lua_sethook (lua_State *L, lua_Hook f, int mask, int count);</p>
<p>Sets the debugging hook function.</p>
<p>Argument f is the hook function. mask specifies on which events the hook will be called: it is formed by a bitwise or of the constants LUA_MASKCALL, LUA_MASKRET, LUA_MASKLINE, and LUA_MASKCOUNT. The count argument is only meaningful when the mask includes LUA_MASKCOUNT. For each event, the hook is called as explained below:</p>
<p>The call hook: is called when the interpreter calls a function. The hook is called just after Lua enters the new function, before the function gets its arguments.<br>The return hook: is called when the interpreter returns from a function. The hook is called just before Lua leaves the function. You have no access to the values to be returned by the function.</p>
<p>The line hook: is called when the interpreter is about to start the execution of a new line of code, or when it jumps back in the code (even to the same line). (This event only happens while Lua is executing a Lua function.)</p>
<p>The count hook: is called after the interpreter executes every count instructions. (This event only happens while Lua is executing a Lua function.)<br>A hook is disabled by setting mask to zero.</p>
</blockquote>
<p>云风的方式是间隔采样的方式，hook LUA_MASKCOUNT，按照一定的间隔进行代码采样，这种方式不太能精确统计每个函数的运行时间，但是对于运行的程序影响较小，从整体消耗百分比的角度分析瓶颈更加准确。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_sethook(cL, profiler_hook, LUA_MASKCOUNT, interval);</span><br></pre></td></tr></table></figure>
<p>LuaProfiler的方式是Hook每个函数的调用和Return逻辑，可以拿到每个函数精确的运行时间，但是这个过程中也就增加了运行消耗。这跟量子力学的理论有那么点相似——你想要观察对象，就会对被观察的对象产生影响。LuaProfiler通过暂停计时的方式让统计的时间更加准确，但是运行时的消耗无法减少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua_sethook(L, (lua_Hook)callhook, LUA_MASKCALL | LUA_MASKRET, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>仔细阅读了一下LuaProfiler的代码，对于一些不太了解的函数也逐一进行了搜索，最后发现其在hook的函数处理中逻辑上并不需要在Lua的栈中添加数据，它用于记录时间消耗的数据在自己组织的一块内存的栈结构中。</p>
<p>最后发现，在callback函数中的lua_gettable操作用来获取profile的状态信息指针，但是把这个数据遗漏在了栈中没有pop出来。我尝试在最后添加了<code>lua_pop (L, 1);</code>操作，编译测试之后没有遇到问题，也解决了ToLua#的报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* called by Lua (via the callhook mechanism) */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callhook</span><span class="params">(lua_State *L, lua_Debug *ar)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> currentline;</span><br><span class="line">  lua_Debug previous_ar;</span><br><span class="line">  lprofP_STATE* S;</span><br><span class="line">  lua_pushlightuserdata(L, &amp;profstate_id);</span><br><span class="line">  lua_gettable(L, LUA_REGISTRYINDEX);</span><br><span class="line">  S = (lprofP_STATE*)lua_touserdata(L, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lua_getstack(L, <span class="number">1</span>, &amp;previous_ar) == <span class="number">0</span>) &#123;</span><br><span class="line">    currentline = <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_getinfo(L, <span class="string">"l"</span>, &amp;previous_ar);</span><br><span class="line">    currentline = previous_ar.currentline;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  lua_getinfo(L, <span class="string">"nS"</span>, ar);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ar-&gt;event) &#123;</span><br><span class="line">    <span class="comment">/* entering a function */</span></span><br><span class="line">    lprofP_callhookIN(S, (<span class="keyword">char</span> *)ar-&gt;name,</span><br><span class="line">		      (<span class="keyword">char</span> *)ar-&gt;source, ar-&gt;linedefined,</span><br><span class="line">		      currentline);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">/* ar-&gt;event == "return" */</span></span><br><span class="line">    lprofP_callhookOUT(S);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_pop (L, <span class="number">1</span>); <span class="comment">/* lua_gettable operation left a value in the lua stack, which makes the tolua param check failed! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我依然有些担心LuaProfiler的作者将这个信息遗漏在栈内是否是有意为之，只是目前这个工具能够正常工作，我就先当作自己fix了一个不过。</p>
<blockquote>
<p>这里说一个插曲，在UWA群中我去问了一下LuaProfiler的情况，有个朋友说他们使用SLua+LuaProfiler没有遇到问题，我还专门有去看了下SLua的Warp函数，感觉其对于参数个数的检查和ToLua差别不大，也是基于相等来做的判定。时间关系，我没有去尝试在SLua中集成来进行测试，有使用的朋友可以自己试下，有结论也期望反馈给我。</p>
</blockquote>
<p>集成之后的LuaProfiler的使用可以参考<a href="http://luaprofiler.luaforge.net/manual.html#analyzer" target="_blank" rel="external">Using LuaProfiler</a>的描述，简单来说使用它提供的summary.lua，结合Excel就可以进行比较好的性能分析。使用-v参数可以统计出包括执行次数、平均时长、总时间消耗在内的更多信息。</p>
<p>#4. 总结</p>
<p>要在Unity中用好Lua需要注意很多东西，脚本语言本身的性能就比静态语言要差一些，如果写得人不够专业，就可能会造成很多问题，包括内存泄露和性能瓶颈。通过这几个工具的集成，可以让项目组的其他同学方便地进行内存检查和性能测试，越早地抓出问题，就可以让后续编写的代码更好。对于我个人来说，这也是对于Lua进行C扩展的一个入门练习，通过阅读代码和尝试修改bug，了解了一些基本函数的意义和使用方法。</p>
<p>后续有时间，我会按照项目的需求对这两个工具进行一些改造。目前它们在信息输出方面还有一些缺失，LuaProfiler由于在运行时会记录很多数据从而导致严重影响游戏的帧率，最后统计的结果也没有调用关系的内容，到时候有了产出再在博客中分享大家。</p>
<p>2017年4月20日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unitydev3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/12/25/unitydev3/" class="article-date">
  	<time datetime="2016-12-25T14:59:07.000Z" itemprop="datePublished">2016-12-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/25/unitydev3/">Unity手游开发札记——从零开始搭建手游开发的工具集</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>从8月中旬到现在12月底，四个多月的时间，经历团队组建、引擎熟悉、基础工作流搭建、核心Demo开发以及一些技术预研的工作，这其中的每一项拿出来都可以写出一篇文章。之前已经聊过一些Unity和Lua相关的技术，今天就主要聊一聊不那么技术的部分——对于一个从零开始组建的小团队，游戏开发的一些基础的工作流程和协作工具，希望可以帮助后来人节省部分时间，也抛砖引玉，想了解下其他团队中有什么更好的解决方案~</p>
<h2 id="1-为什么需要"><a href="#1-为什么需要" class="headerlink" title="1. 为什么需要"></a>1. 为什么需要</h2><p>商业游戏的开发是一个大工程，需要参与的职位很多——策划、程序、美术、QA、营销、外包等等，每一个职位的人也不少，比如策划团队可能会有6-7人，程序团队可能会在10人以上，还会区分客户端与服务端。要想让游戏开发的工作可以更好更快地推进，确保每个职位之间和内部的协作都是顺畅的，需要工作流的精确定义和强大工具的支持。</p>
<p>在游戏开发中，程序的职责不仅仅是实现游戏玩法逻辑，构建合理的工作流程和开发强力的工具集也是工作的一部分。这一部分内容可能无法体现在最后发布的游戏中，但是在保证项目按时完成，提升整个团队的工作效率方面却具有非常重大的意义。</p>
<p>在大公司中，这部分内容会由IT、运维等其他部门的同事提供，但是在一家小公司，一切只能自己动手。作为程序组的负责人，特别是最初只有我一个程序的情况下，这份看上去<em>只是进行一些工具调研，然后部署</em>的工作就毫无疑问地落在了我的身上。实话实说，相对于实现一个有意思的玩法，这个过程的确有些枯燥无趣，但回头来看，这些工作让整个团队可以顺利地推进工作，沉淀知识，反思问题，也是一种成就感。</p>
<h2 id="2-包含哪些内容"><a href="#2-包含哪些内容" class="headerlink" title="2. 包含哪些内容"></a>2. 包含哪些内容</h2><p>这里涉及到的绝大部分工具都是不自己开发的，而是对于世面上已有的工具的试用和选择。本文也不进行深入的技术探究，只从自己团队需求的角度出发，记录这些工具的选择过程和决策原因。涉及的部分包括沟通工具、知识分享、版本管理、项目协作与管理、自动化构建工具、编辑器和部分程序开发工具这几个方面。</p>
<h2 id="3-沟通工具"><a href="#3-沟通工具" class="headerlink" title="3. 沟通工具"></a>3. 沟通工具</h2><p>在团队组建的最初，我们只有一个微信群来进行沟通。在搬进新的工作地点之后，公司正式成立，就需要确定对内和对外使用的沟通工具。这部分内容看上去非常简单，但也有很多值得思考的内容。</p>
<h3 id="3-1-邮件服务"><a href="#3-1-邮件服务" class="headerlink" title="3.1 邮件服务"></a>3.1 邮件服务</h3><p>邮件服务作为一个最为正式的沟通工具，无论是对内还是对外，都需要可以正常使用。可以进行的选择是自己搭建一个邮件服务器还是使用比如腾讯或者阿里这样大公司提供的企业级邮箱。在经过一些调研、对比和讨论之后，出于对邮件内容安全性的考虑，我们选择了自己搭建的方式。<br>使用<strong>MDaemon</strong>作为邮件服务器，申请了公司的域名，购买了阿里云的主机，搭建过程交给了一个朋友帮忙（所以不要问我是不是破解版，我不会回答的。。。），目前的工作方式是我自己远程上去手动维护邮件账户和列表。（这有点蛋疼，但不频繁还可以忍受…）<br>客户端我们没有强制规定，但大部分使用了网易的闪电邮，这完全是习惯使然，其中的日历和会议邀请功能还是很实用的。</p>
<h3 id="3-2-即时通讯工具"><a href="#3-2-即时通讯工具" class="headerlink" title="3.2 即时通讯工具"></a>3.2 即时通讯工具</h3><p>每个团队都需要IM工具，在网易的时候使用的是POPO，但是作为一个对外好久没有更新的工具，而且是“老东家”的产品，有点怕。我们调研了Slack、钉钉、微信企业版，考虑了QQ，最终选择了钉钉。我个人很喜欢Slack这一类型的IM工具——使用频道代替群的概念，信息永久保存、可以修改搜索消息，这些设计减少了水群的存在，也让沟通的人说话更加谨慎高效。</p>
<p>但是，Slack没有中文版本，询问了一下开发者，貌似近期也没有推出的计划，而国内几个小团队做的相似版本不太敢去用，怕哪天倒闭了聊天内容都没办法导出来。相比之下，虽然钉钉有很多我个人不喜欢的地方——譬如“钉一下”的概念是为老板服务的——我们还是无奈选择了它，有如下几个原因：</p>
<ol>
<li>带有简单的OA，比如部门管理、签到、审批，这些是我们初期需要但又不想花太多时间去开发新的内容；</li>
<li>有比较完备的桌面版和移动版；</li>
<li>使用方式还是比较常规的方式，适合策划和美术上手；</li>
<li>有Open API提供，可以进行一些工具的开发；</li>
<li>阿里“爸爸”怎么说也是家大公司，倒掉的概率比较小。。。对于我们这种小团队的信息也懒得偷看（迫害妄想症）。。。</li>
</ol>
<p>当然用了这几个月也有很多槽点想吐：</p>
<ol>
<li>完全没办法图文混排，美术吐槽这点吐槽了好久；</li>
<li>传输文件不是点对点的方式，而是上传然后再下载，也无法传输文件夹，我们现在局域网传输都不用它了，嫌慢又怕外泄；</li>
<li>出于安全的考虑，Open API不开放获取聊天信息的接口，导致我们现在一些想做的便捷功能没办法做；</li>
<li>我只把它当做一个IM工具，不想钉别人，也不想被别人钉……（纯吐槽）</li>
</ol>
<p>总之，小而精的团队，可以尝试下Slack~~</p>
<h3 id="3-3-现场沟通"><a href="#3-3-现场沟通" class="headerlink" title="3.3 现场沟通"></a>3.3 现场沟通</h3><p>对于小团队来说，吼一嗓子，或者跑到位置上去聊，可能是最为快速高效的工作方式了。这不需要任何工具，只是有时候需要提醒注意讨论对于其他人工作效率的影响，比较长或者涉及人比较多的讨论还是建议去会议室进行。但最好进去之前明确讨论主题，注意讨论时间，否则很容易错过饭点。。。（流泪）</p>
<h2 id="4-知识共享"><a href="#4-知识共享" class="headerlink" title="4 知识共享"></a>4 知识共享</h2><p>团队开发需要知识共享，一些规范也需要让别人可以方便地查找，对于后进入团队的人，也可以尽快熟悉规范，避免一些坑重复去踩。因此我们需要一些知识和文件共享的方式。</p>
<h3 id="4-1-文件共享"><a href="#4-1-文件共享" class="headerlink" title="4.1 文件共享"></a>4.1 文件共享</h3><p>文件共享分为两种，不需要版本控制的我们使用了FTP的方式，购买了一台windows server的服务器放置在了内网，然后直接使用了系统自带的FPT服务，用于文件共享和一些内网的文件传输中转，简单粗暴。<br>需要版本控制的文件，比如策划文档，我们使用了SVN进行管理。</p>
<h3 id="4-2-文档共享"><a href="#4-2-文档共享" class="headerlink" title="4.2 文档共享"></a>4.2 文档共享</h3><p>基本上是出于个人习惯的考虑，文档共享方面推荐团队使用了<a href="https://www.yinxiang.com/" target="_blank" rel="external">印象笔记</a>。一开始团队中有人吐槽它没有文件夹管理太难用，其实我觉得Tag的方式比文件夹更加方便合理。当然也有一些不方便的地方：</p>
<ol>
<li>无法支持两个人同时编辑一份文档，甚至一个人看的时候光标只要在文档内就会把文档锁定别人无法修改。当时考虑了一下<a href="https://shimo.im/" target="_blank" rel="external">石墨文档</a>，但是没有推广去用，需要的朋友可以去看下。</li>
<li>对于Markdown的支持不够好，排版太难看。。。叹气。<a href="https://maxiang.io/" target="_blank" rel="external">马克飞象</a>虽然可以用，收费不说，还不能在印象笔记中修改，怎么共同编辑，摔。</li>
<li>美术不乐意用，嫌弃说都是文字不够直观……这个我也没办法，手动摊手。</li>
</ol>
<p>知识共享和记录是一件非常重要的事情，前两天就遇到部署Jenkins的时候没有做记录，然后重启机器遇到问题忘记怎么弄又捣鼓半天的事情。年纪大了，事情多了，脑袋不好使了，烂笔头更重要了。更何况，很多东西是规范性的，需要其他职位的人遵守，口头的约定总是会忘记或者记不清楚，落实到文字上才更有约束力。</p>
<h2 id="5-版本管理"><a href="#5-版本管理" class="headerlink" title="5 版本管理"></a>5 版本管理</h2><p>前面提到了，策划文档使用了SVN管理，游戏工程也是选择了SVN，原因是团队大部分成员习惯了SVN的使用。如果只有程序团队使用，可能就去推行Git了，但是想想要给美术和策划培训Git，还有解释本地版本和服务器版本的概念就头疼。在刚进入网易的时候有一段时间是跟着美术处理各种svn冲突，clean up无效等问题，深深体会到svn和git这种按照程序员理性思维建立的工具，感性的美术需要花挺多精力去理解。</p>
<h3 id="5-1-外链问题"><a href="#5-1-外链问题" class="headerlink" title="5.1 外链问题"></a>5.1 外链问题</h3><p>在工程中，避免不了的是有些目录需要同时出现在多个地方，比如客户端与服务端可能会共用一份数据文件，当数据修改的时候，在多处进行修改是不合适的做法，维护起来很麻烦。于是版本管理软件提供了外链的功能，比如svn的externals。但是外链有一个很严重的问题是当你需要建立分支的时候，如果不做任何修改，外链还会是指认到原始trunk上的路径，当外链很多的时候，就需要针对每个外链单独建立分支，然后修改整个分支中所有外链的路径到正确的分支位置去。在项目后期，需要编写一个单独的脚本来进行分支的创建，而不是一条简单的cp指令就可以了。与外链相对应的是所谓的“内链”，即路径不再是一个以https或者svn开头的全地址路径，而是一个类似<code>../../../CommonData</code>这样的相对路径。这样，只要保证分支是在根目录创建的，内链就是分支内部的路径，不需要做任何额外的修改。当然，内链无法跨svn repository运作，如果是另外一个svn repository的内容，只能使用外链的方式。<br>SVN的这部分构建和设计工作最好在项目初期做好规划，否则后期进行分支维护的时候会比较麻烦，容易出错。</p>
<h3 id="5-2-工具使用"><a href="#5-2-工具使用" class="headerlink" title="5.2 工具使用"></a>5.2 工具使用</h3><p>SVN服务使用了最为简单的VisualSVN Server，带有gui，方便易用，目前比较恶心一点的是为别人创建账号的时候密码输入只能在界面上进行，暂时没时间调研更好的工具来自己创建账号。<strong>权限的分配完全按照Group进行，从不单独针对某一个账号进行权限分配</strong>，这点是在网易的时候维护SVN权限时老大强调的一点，方便，不容易出错。虽然是小团队，但是SVN的权限管理还是要做好，否则代码泄露出去隐患还是很大的。</p>
<p>SVN服务端的Hook目前只加了两个：</p>
<ol>
<li>不允许提交过短的log，强制防止有人偷懒不写log；</li>
<li>允许log被提交者自己编辑。</li>
</ol>
<p>客户端基本推广的是小乌龟，Mac和Linux就使用命令行。美术同学有人喜欢装一个中文语言包，就按照各自的喜好去用。这里有几个小Tips提供给不太熟悉小乌龟的人：</p>
<ol>
<li>按住Shift点击右键，弹出的svn菜单里会多一些比如“删除不再版本控制下的文件”这样的快速选项；</li>
<li>在Settings中，Main Context Menu中可以添加常用的菜单选项，比如revert、Show Log，这样就不需要进入SVN的二级菜单了；</li>
<li>如果在update的时候，有更新的文件被比如3DS Max、Photoshop等软件打开着的时候，可能会出现被锁死的情况，这时候提示你要进行Clean up操作，在关闭了相应软件之后，如果Clean up仍然失败，可以尝试使用如下的代码来解决。如果仍然不行，可以只删除掉.svn文件，然后重新check out，这样既可以保留已有的修改，又可以避免下载所有的文件，加快速度。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlite3.exe .svn/wc.db &quot;select * from work_queue&quot;</span><br><span class="line">sqlite3 .svn/wc.db &quot;delete from work_queue&quot;</span><br><span class="line">ECHO &quot;DONE!&quot;</span><br><span class="line">PAUSE</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-3-美术外包资源管理"><a href="#5-3-美术外包资源管理" class="headerlink" title="5.3 美术外包资源管理"></a>5.3 美术外包资源管理</h3><p>除了游戏工程之外，美术外包或者内部制作的Max等资源也需要进行一定的版本管理。本质上说，使用svn对这部分资源进行管理并不合适，因为这些资源大都是二进制而非文本的，svn这种代码版本管理软件并不非常合适，更好的选择是NXN和Preforce这样的——有图形化的树状结构界面，不需要完整下载到本地，修改之前必须获取锁——这些这对于美术来说是更加直观、容易理解的方式。<br>但是，NXN收费很贵，Preforce也只允许20人以下的团队免费使用。花费了一些时间去做调研，但是目前我们出于统一和成本的角度考虑，依然使用SVN来对这部分的美术资源进行管理，后续可能会进行一些改进。</p>
<blockquote>
<p>在一个团队中，推广一个工具的使用需要不少的人力成本，尤其是美术和程序是两种不太相同的思维方式，而且很多美术对于工具使用都是一种机械记忆而非理解原理的方式，因此这也限制了一些可能更好的工具的应用。</p>
</blockquote>
<h2 id="6-项目管理与协作"><a href="#6-项目管理与协作" class="headerlink" title="6. 项目管理与协作"></a>6. 项目管理与协作</h2><p>项目管理这一部分也是花费了较多时间的，调研和试用了一系列的工具，稍微整理一下：</p>
<ol>
<li><strong>Project和Excel</strong>，这是最为传统的项目管理软件了，简单来说基于甘特图，适合项目经历做排期和监控项目进度，但是对于团队中各个职位的同事协作帮助并不大。</li>
<li><strong>Redmine</strong>，在网易的时候也是使用Redmine进行项目管理的，后来网易公司也自己开发和扩展了“易协作”这样的平台。这应该是最为老牌和经典的项目协作软件了，免费开源，也有比较丰富的插件提供。</li>
<li><strong>偏向敏捷开发的协作平台</strong>，比如<a href="https://www.teambition.com/" target="_blank" rel="external">teambition</a>、<a href="www.tower.im">Tower</a>、<a href="www.worklite.com">Worklite</a>等等，试用了几个，感觉大同小异，和Redmine的区别在于更加偏向于小团队敏捷开发，一些跨职位的流程功能提供不是非常全面，比如有些就没有提供从策划提单、程序做单、QA测单的流程性的东西。</li>
</ol>
<p>目前我们采用了内网Redmine+worklite的方式。出于搭建方便，节省时间的考虑，从淘宝购买了一套组织好插件的所谓“一键部署”的Redmine版本，自己做了两个简单的调整：</p>
<ol>
<li>我的工作台看板增加若干列，提供更多信息；</li>
<li>ticket可以进行主题和描述的编辑功能。<br>部署过程还算顺利，除了遇到了端口和VisualSVN Server使用的端口冲突之外，没遇到太多问题，后面修改这两个调整花费了一些时间，对于Ruby和Web开发都不是很熟悉，一点点通过代码搜索来寻找修改的地方，然后不断测试修改才搞定。<br>Worklite我们用在对外美术外包的一些工作管理和面试流程管理上，因为外网方便访问，所以这么来做。我个人是很想推进一些敏捷协作平台的使用的，无论从理念上还是从美感上，可能都比Redmine要舒服一些，但是最终在试用之后没有这么来做的原因有如下几个：</li>
<li>数据安全性的考虑，项目的一些内容，比如玩法设计可能会在任务单中有体现，这些是想保密的，放在外网服务器还是有些担心；</li>
<li>做平台的小公司倒掉了，我们怎么办？迁移的成本很大。</li>
<li>比如前文提到过的从策划提单、程序做单、QA测单的工作流程，很多敏捷工具不能很好地定义和推进；</li>
<li>有一些硬性的功能修改需求，使用Redmine花费一些时间还有可能实现，使用别人的平台，可能只能去提建议；</li>
<li>在试用的时候，遇到过外网访问困难的情况，比如刷新慢，上传文件比较慢等等问题，还是内网效率高速度快；</li>
</ol>
<blockquote>
<p>对于工具的选择，往往有各方面的限制，其实不完全是决定着自己的喜好可以左右的……</p>
</blockquote>
<h2 id="7-自动化构建工具"><a href="#7-自动化构建工具" class="headerlink" title="7. 自动化构建工具"></a>7. 自动化构建工具</h2><p>网易内部有一套很有趣的网易POPO机器人，来辅助比如导表、打包这样的自动化构建过程，减少程序员的工作量。会申请一个特定的机器人账号，把它加入到一些工作群，只需要在这些群里输入比如“Android打包”，它就会构建已经建立好的自动化脚本进行打包，并把结果输出在群里，比如失败的错误信息，成功之后的下载链接等等。<br>这套东西非常方便，最初选择钉钉的时候看到有Open API就想去构建一下这套自动化的流程，后来经过测试和向官方询问发现无法通过接口获取群的聊天信息，其实后来也想通过网络抓包、钉钉软件破解等方式来做，但是太过麻烦，而且维护起来比较费时，所以选择了使用Jenkins+钉钉的方式。<br>Jenkins本身就是自动化持续构建的工具，钉钉只是用来反馈一些信息给策划、美术这些不习惯使用Jenkins的同事，比如打包结果，导表的错误信息等。这里提供一个简单的通过钉钉发送消息的Python脚本，需要的可以拿去用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> Config</span><br><span class="line"><span class="keyword">from</span> HTTPUtils <span class="keyword">import</span> http_get</span><br><span class="line"><span class="keyword">from</span> HTTPUtils <span class="keyword">import</span> http_post</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TokenManager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Token每隔两个小时过期一次，再次获取刷新时间间隔。"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(TokenManager, self).__init__()</span><br><span class="line">        self._token = <span class="keyword">None</span></span><br><span class="line">        self._update_time = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_token</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (self._token <span class="keyword">and</span> (time.time() - self._update_time &lt; <span class="number">1000</span>)):</span><br><span class="line">            self._token = get_access_token()</span><br><span class="line">            self._update_time = time.time()</span><br><span class="line">        <span class="keyword">return</span> self._token</span><br><span class="line">        </span><br><span class="line">token_mgr_instance = TokenManager()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_access_token</span><span class="params">()</span>:</span></span><br><span class="line">    access_token = <span class="keyword">None</span></span><br><span class="line">    ret, msg = http_get(<span class="string">"https://oapi.dingtalk.com/gettoken?corpid=%s&amp;corpsecret=%s"</span>%(Config.CORP_ID, Config.CORP_SECRET))</span><br><span class="line">    <span class="keyword">if</span> ret:</span><br><span class="line">        access_token = msg[<span class="string">"access_token"</span>]</span><br><span class="line">    <span class="keyword">return</span> access_token</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(msg, chat_id = Config.ROBOT_CHAT_ID)</span>:</span></span><br><span class="line">    access_token = token_mgr_instance.get_token()</span><br><span class="line">    data = &#123;<span class="string">"chatid"</span> : chat_id, </span><br><span class="line">            <span class="string">"sender"</span> : Config.ROBOT_ID,</span><br><span class="line">            <span class="string">"msgtype"</span>: <span class="string">"text"</span>,</span><br><span class="line">            <span class="string">"text"</span>:&#123;</span><br><span class="line">                <span class="string">"content"</span> : msg</span><br><span class="line">            &#125;&#125;</span><br><span class="line">    ret, msg = http_post(<span class="string">"https://oapi.dingtalk.com/chat/send?access_token=%s"</span>%access_token, data)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p>
<p><code>http_get</code>和<code>http_post</code>两个方法使用了Requests，基本定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_get</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">return</span> handle_result(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">http_post</span><span class="params">(url, data)</span>:</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">        <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span>,</span><br><span class="line">        <span class="string">"Accept-Charset"</span>: <span class="string">"utf-8"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.post(url, headers=headers, data=json.dumps(data), timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">    result = json.loads(response.text)</span><br><span class="line">    <span class="keyword">return</span> handle_result(result)</span><br></pre></td></tr></table></figure>
<p>最初的时候使用urllib2，但是在mac系统上遇到了SSL错误的问题，研究半天最后还是使用了Requests库来做。Jenkins的搭建也是花费了一些时间和精力，包括在Mac机器上的权限问题，编码问题，SVN权限问题等等，可惜的是当时没有做完整详细的记录，一些坑没有办法完全记录下来，但是遇到了之后通过Google都可以找到解决方案。</p>
<blockquote>
<p>通过这一套方案，加上一些基于Python脚本构建的自动化打包、导表等流程，就可以让一些原本需要程序来做的工作编程策划/美术驱动机器人来完成，没有错误的情况下无需程序参与。</p>
</blockquote>
<h2 id="8-编辑器"><a href="#8-编辑器" class="headerlink" title="8. 编辑器"></a>8. 编辑器</h2><p>游戏开发的最理性情况，是程序编写玩法框架，策划来填充游戏内容，比如UE4的蓝图功能、Unity的PlayMaker插件，就是一种对于程序工作的释放。但是在一个大型商业游戏的开发中，引擎原生提供的编辑工具还是无法为策划、美术和UI提供完整的游戏内容实现工具，需要程序来实现一些与游戏玩法相关的编辑器或者代码功能，比如技能编辑、战场编辑器等等。</p>
<p>网易早期，加上现在了解到的一些创业小团队，是以Excel表为核心提供策划编辑的功能。Excel的强大功能和灵活的编辑方式的确为策划提供了很多便利，但是还有一些小问题：</p>
<ol>
<li>比较难做到所见即所得，即对于有些东西的编辑不够直观，比如场景中的位置等；</li>
<li>一些多维的数据需要进行拆分到多张表里的方式实现，设计和填写上会有些困难；</li>
<li>比较难限制策划填写一些数据的正确性，比如一个外键值，策划填写时需要去其他表中查询这个key值是否存在，编辑器就可以提供下拉列表这样的方式来做。（Excel使用比较麻烦的方式也可以做到，或者在导表程序的后处理中检查。）</li>
</ol>
<p>对于这样的数据，我们采用编辑器的方式来实现，之前项目使用了一套元数据的编辑器框架，不需要维护编辑器的人修改界面，只需要简单增加或者修改一些元数据就可以了。Unity引擎本身的编辑器就是类似这样的实现思路，因此我们无需做额外的太多工作。</p>
<blockquote>
<p>编辑器的开发需要消耗程序不少的工作量，因此有时候在进度紧张人力不够的情况下，需要评估编辑器能够产出的价值。当编辑器真正能够让使用者的工作效率得到的提升远大于程序付出的时候，编辑器的意义才能够展现出来。</p>
</blockquote>
<h2 id="9-程序开发工具"><a href="#9-程序开发工具" class="headerlink" title="9. 程序开发工具"></a>9. 程序开发工具</h2><p>程序开发工具可以说的有很多，这里分为Unity和Lua脚本两部分进行简单的描述。</p>
<h3 id="9-1-Unity引擎部分"><a href="#9-1-Unity引擎部分" class="headerlink" title="9.1 Unity引擎部分"></a>9.1 Unity引擎部分</h3><p>选择了Unity作为游戏开发的引擎，为了方便热更使用了Lua作为游戏逻辑开发的脚本语言。Unity引擎对于游戏调试的支持还是很好的，我们在开发便利性方面只引入了两个增强型的工具：</p>
<ol>
<li>Unity Editor内的SVN集成插件：<a href="https://www.assetstore.unity3d.com/en/#!/content/49128" target="_blank" rel="external">Svn Tools Lite</a></li>
<li>控制台Log查看支持搜索等功能的扩展：<a href="https://www.assetstore.unity3d.com/en/#!/content/42381" target="_blank" rel="external">Console Enhanced Free</a></li>
</ol>
<h3 id="9-2-Lua部分"><a href="#9-2-Lua部分" class="headerlink" title="9.2 Lua部分"></a>9.2 Lua部分</h3><p>Lua语言方面，我们使用了<a href="https://github.com/lipp/tango" target="_blank" rel="external">Tango</a>作为<strong>跨Lua虚拟机通讯</strong>的解决方案。在游戏脚本开发中，支持断点调试通常比较困难，或者在联网情况下并不非常好用，比如有可能一断点就网络就断掉了，因此类似于Telnet的方案，可以在另外一个Lua虚拟机中直接连接游戏进程中的Lua虚拟机，进行一些属性查看、方法调用，也是一种非常实用的方法，甚至可以支持远程连接移动设备进行调试。</p>
<p>这种多虚拟机的整合方案在网易内部应用得非常广泛，因为我参与的大部分项目都使用了Python语言，因此使用<a href="https://rpyc.readthedocs.io/en/latest/" target="_blank" rel="external">RPyC</a>作为解决方案，为游戏引擎外运行的编辑器开发提供了非常多的便利，与测试用的服务器相连接，也可以通过编辑器/控制台直接更新服务器内存数据。在手游项目中，也大量的使用于设备上的测试。可惜的是目前使用Lua语言，Tango虽然也提供了类似的功能，但是相比如RPyC来说完备性和易用性差很多，而且它是一个5年没有维护的项目了。。。好在基本的功能还是可以使用的，因此也就不再挑剔什么了。</p>
<p>在游戏逻辑的开发中，可以利用Lua脚本语言的动态特性，提供运行时Reload的功能，在不重启游戏的情况下，修改游戏逻辑之后直接一键Reload游戏代码，然后查看修改结果。这可以非常大地提升游戏开发效率，当然对于添加函数或者修改数据结构这样的修改可能会存在一些问题，适用性有一定的限制。</p>
<p>Lua的断点调试方式我们目前还没有走通，ToLua#的中提供了一套基于<a href="https://studio.zerobrane.com/" target="_blank" rel="external">zerobrane</a>的调试方法，但是我们试用还存在一些问题，断点只能停在main函数入口的地方，其他位置无法断点，还需要一些时间踩坑。</p>
<p>Lua这部分可以聊的有很多，语言特性、面向对象的结构等等，有时间计划拿出单独的一篇博客来讲，这里就只提供上面的几个工具的实现思路，有兴趣的可以留言详细聊。</p>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10. 总结"></a>10. 总结</h2><p>洋洋洒洒写了这么多，其实有技术含量的东西不多，但这些零零碎碎的工作，却又是从零开始组织一个手游开发公司必不可少的过程。一个程序的负责人必须利用有限的时间和人力，使用尽量少的资源搭建起让所有职位都可以正常运转与合作的工作流程与工具集合，而且尽量让这个流程更高效。</p>
<p>从大公司的“温室”里“逃”出来，想做些不一样的事情，但初始要做的，却是这些在大公司不屑于去做的事情。这虽然有点讽刺的以为，但这个过程，也是学习和反思的过程——从之前的工作流程中提取好用高效的部分，反思哪些流程是可以改变和改进的。惭愧的是，现在搭建和使用的这些工具，大多还是“网易 like”的模式，不过已经看清了那些好处和坏处，等以后有人力和时间的时候，可以进行大刀阔斧的改进，这些是在大公司不太会去思考和改变的。</p>
<p>2016年12月25日夜 于杭州家中<br>PS：圣诞夜，老婆去马来西亚学习潜水了，我自己一个人在家写这篇总结，想想还有点凄凉。。。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工具/">工具</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unitydev2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/11/27/unitydev2/" class="article-date">
  	<time datetime="2016-11-27T09:52:53.000Z" itemprop="datePublished">2016-11-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/27/unitydev2/">MMO游戏优化经验分享沙龙总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天去上海参加了UWA公司的张鑫和张强进行了一场关于MMO游戏开发和性能优化的沙龙，活动链接为：<a href="http://blog.uwa4d.com/archives/Openday1126.html" target="_blank" rel="external">UWA优化日上海站|传统MMO手游性能该如何突围？</a>。虽然第二场场景分块加载部分的内容没有预期中对目前的项目那么有帮助，再加上最后因为赶火车没有听完Q&amp;A的环节就离开了（然而还是没有赶上火车，此中悲苦就不提了。。。），有些疑问没有提出来讨论，略有遗憾，但对于我这样一个刚刚接触Unity的新兵来说，收获颇丰。因此这里做一个简单的记录和整理，只包含现场讨论我印象比较深的一些点，与讲座内容的顺序没有直接对应关系，更加详细、条目性的内容可以参考官方放出的正式文档。</p>
<h2 id="0-关于UWA"><a href="#0-关于UWA" class="headerlink" title="0. 关于UWA"></a>0. 关于UWA</h2><p>张鑫博士介绍了UWA成立这一年多时间内做过的事情，我还是比较赞赏有组织在做这件事情的，可以说是Unity引擎和用户之间除了官网文档和官网技术支持之外的一座桥梁。虽然说他们目前的存在价值和盈利方式依赖于Unity引擎和这样一个生态圈，但是对于程序员来说，它们比单纯的引擎部门接近游戏产品，和做产品的比又更纯粹，没那么功利，介于两者之间。如果有合适的机会我还是挺想做一做这样的事情的，哈哈~</p>
<p>目前来说，能有这样的一群人帮忙提供一些技术上的分享，一些坑可以拿出专门的时间和精力去踩和分析，对于没有引擎组的小团队来说是非常好的事情。</p>
<p>张鑫博士提到他们提供热更新方案，会后单独问了一下还是只支持Android的版本，Lua方案的热更新还没有人力去做。希望后面可以有人力来做一些这方面的踩坑和性能优化工作……</p>
<p>##1. UI系统中的Mesh重建</p>
<p>在UI系统的优化中，着重提到了Mesh重建的过程，这通常是一个消耗最大的部分，因此也是优化需要关注的重点。在NGUI中，这一过程发生在Panel的LateUpdate函数中——由于NGUI是插件的形式，因此这一过程是在C#中的，每次需要改变渲染网格时都会销毁内存中的mesh进行重建操作。而对于UGUI来说，这一过程是在Cavas的BuildBatch中进行的，已经被封装成了Native的实现，因此在UGUI中这部分<strong>没有额外的堆内存分配</strong>，这也是UWA官网把UGUI在运行时分配的堆内存大小标准定义为小于2M，而NGUI的建议标准是小于20M的核心原因。</p>
<p>那么，如何降低UI系统中Mesh重建的次数呢？主要从以下两点出发：</p>
<blockquote>
<ul>
<li>当ui发生改变，比如有组件的添加、删除、遮挡关系改变等事情发生的时候会需要重建Mesh，<strong>而当ui的transform发生改变的时候，如果不影响原本的遮挡关系，是不会导致Mesh重建的过程的</strong>。</li>
<li>UGUI中Mesh的重建的<strong>基本单位是Canvas</strong>。</li>
</ul>
</blockquote>
<p>上述两点分别对应两个优化思路：</p>
<blockquote>
<ul>
<li>尽量减少Mesh重建发生的次数；</li>
<li>当一定需要Mesh重建的时候，尽量减少Mesh重建影响的范围；</li>
</ul>
</blockquote>
<p>针对第一点，除了不要进行不必要的ui修改操作之外，<strong>对于需要频繁切换的复杂界面</strong>，张鑫博士给出的建议是：</p>
<blockquote>
<p>“不要使用实例化/销毁操作来实现界面的切换，会有很大的额外开销，对于active/deactive操作来说也会有mesh重建的过程。推荐通过将其坐标移出视窗之外，或者通过Camera的Layer机制来隐藏界面这两种方式具有最好的性能效果。”</p>
</blockquote>
<p>一个使用案例是背包界面，有大量的item，创建过程消耗也会很大，如果内存允许的话，使用上述方法会有最小的性能开销。</p>
<p>而尽量减少Mesh重建影响的范围则对应一个基本原则——<code>动静分离</code>，即把不需要动态改变和需要频繁地动态改变的组件分离出来。按照上述的第二点，可以使用canvas进行<code>动静分离</code>。就是说比如某个组件下面挂的东西是一个会动态变化的部分，那就把它独立成一个canvas。比如仍然以背包界面为例，滑动内容会导致界面的变化，在滑动过程中每帧都会有Mesh的重建操作。把滚动的部分做成单独的Canvas，这样背景图片和标题等部分就不会被每帧重建了。</p>
<p>这里需要着重注意的是一些会频繁改变的动态部分，比较容易遗忘，比如聊天中的<strong>动态表情，角色坐标信息</strong>的显示等部分，在开发过程中需要着重注意。</p>
<blockquote>
<p>这里我的一个疑问是如果划分过细，过多的Canvas是否会导致UGUI有额外开销？比如是否不同Canvas上的界面元素即使使用Batch后的图，也无法合并Draw Call？这是在开发中需要注意权衡的一个点。</p>
</blockquote>
<p>之前有讨论过<code>动静分离</code>的概念，但是进行分离的基本规则和原理并不是很清楚，张鑫博士的沙龙从性能分析的具体数据出发，结合具体函数的作用，讲解得清晰透彻。<br>另外有几点关于ui优化的笔记：</p>
<blockquote>
<ul>
<li>NGUI中UITexture不会被合并，建议使用UISprite；（我们项目目前使用UGUI，因此NGUI的不是很熟悉，不知道UGUI中有没有无法合并的控件？）</li>
<li>UI应该尽量避免重叠，尤其是看上去不重叠但是实际上有半透区域存在重叠，会导致Unity不进行合并操作，增加Draww Call数量。</li>
<li>在Unity 5.2之后的版本中，ui控件的z值不为0的情况下不会进行合并。（不知道这是为了解决遮挡或者什么问题而修改的<code>特性</code>，还是Bug，在制作的时候注意一下，尤其是做角色的3D血条有深度更改需求的情况下。）</li>
<li>背包界面的优化中提到了<strong>PixelPerfect的设置</strong>，这是一个对齐像素的效果可以让字体等显示的效果更好，比如在背包内容滚动的时候，每帧都会有比较大的消耗在这上面，可以<strong>考虑关闭掉</strong>。</li>
<li>UI中Mesh需要的顶点数量如果可以控制在<strong>1000以内</strong>，Mesh合并的效率就会比较好。过多的顶点数量在全部是静态的情况下问题不大，但是一旦涉及到动态界面就会造成卡顿。</li>
<li>UI部分的Draw Call建议控制在<strong>20~30之间</strong>，是一个比较理想的情况。</li>
</ul>
</blockquote>
<h2 id="2-血条优化案例"><a href="#2-血条优化案例" class="headerlink" title="2. 血条优化案例"></a>2. 血条优化案例</h2><p>UWA做了一个血条性能分析的Demo，也是和UI有关。</p>
<p>通常MMO游戏中血条会比较多，比如一些PVP或者PVE玩法中，血条会有几十个甚至上百个，他们会随着怪物的死亡等消失，又会随着新的怪物产生而重新出现。这里需要注意的点有如下几个:</p>
<blockquote>
<ul>
<li>通常比较直接的思路是创建一个缓冲池，用完丢回去，需要的时候先冲池子里拿。这里依然会有一些性能问题，因为放回缓冲池的操作和重新放回场景中的操作会有SetParent的过程，在UGUI中这一过程会导致控件进行一系列的初始化操作，造成卡顿等问题。UWA的建议是使用移除视窗之外的操作来代替SetParent操作，可以提升性能。</li>
<li>在掉血跳字等字体的部分美术同学喜欢使用Outline等效果，一次Outline对于一个字来说会多绘制上下左右4遍，因此对于内容可控的部分建议直接使用 <strong>静态字体</strong>。</li>
<li>对于频繁出现又消失的战斗提示信息等部分，可以使用<code>.text = ”“</code>的赋值操作，即把文本的内容赋值为空的方式来代替Active和Deactive。</li>
<li>如果血条非常多的情况下，可以考虑拆分成多个Canvas，会有一些意想不到的优化效果。UWA做测试观察到现象是每个Canvas的性能消耗与其中的血条数量不是成正比的，而是一种超线性的关系，这可以理解，在每一控件都可能发生变化的情况下，需要重建整个Canvas，那这是一个n*n的关系。（当然说是n^2的关系也不准确，因为每帧改变1个和改变n个都只会重建一次，但是从统计概率上来说，数量越多，每帧需要进行Mesh重建的概率就越大，重建消耗也是越大的，因此是超线性的。）这里还是一个需要进行Draw Call和重建消耗的折中考虑的点。</li>
</ul>
</blockquote>
<h2 id="3-多线程渲染"><a href="#3-多线程渲染" class="headerlink" title="3. 多线程渲染"></a>3. 多线程渲染</h2><p>多线程渲染是我在网易的时候跟过的一个大坑。。。当然不是我做的开发，而是我们项目比较早在使用引擎组做的这一功能，从集成过程到做兼容性测试遇到过很多问题，比如某些设备上莫名其妙的Crash。</p>
<p>张鑫博士说他们从他们的经验来看，Unity 5.3版本之后多线程渲染的功能已经是一个比较稳定的版本了，现在已经有正在运营的项目在开启多线程渲染。因此整体上还是可以比较放心地开启的。多线程渲染对于PostEffect的提升效果很大，他们做了一个测试可以让CPU消耗从平均20ms降低到平均2ms，也有项目开始之后出现顿卡。</p>
<p>与之前了解的一样，开启多线程渲染之后的性能提升效果根本上和是CPU瓶颈还是GPU瓶颈有关，不同设备效果不同，不同游戏的瓶颈也不同，因此要各个项目自己测试来看，因此UWA官方的说法是——</p>
<blockquote>
<p>”推荐各个项目<strong>尝试开启</strong>。“</p>
</blockquote>
<p>这部分提到如果在观察Profile面板时发现WaitingForJob很高，就说明CPU在等子线程，就已经有性能问题了，当出现PutGeometryJobFence的时候，性能问题就已经很严重了。</p>
<h2 id="4-动态阴影的技术方案"><a href="#4-动态阴影的技术方案" class="headerlink" title="4. 动态阴影的技术方案"></a>4. 动态阴影的技术方案</h2><p>MMO开发中角色阴影已经成为了一个标配，UWA经过测试，Unity官方的Build-in ShadowMap的性能还是最好的，推荐使用，只是效果相对差，而且在Mobile设备上无法支持原生的软影（存疑，需要自己测试一下效果）。</p>
<p>而Projector的实现方式比较适合只有一个角色需要阴影的情况，推荐了两款插件：</p>
<blockquote>
<ul>
<li>Fast Shadow Projector 只支持静态物体；</li>
<li>Fast Shadow Receivor 可以将接受阴影的物体拆分出需要阴影的独立的mesh，提升渲染速度，可以支持柱子这样非平面的物体。</li>
</ul>
</blockquote>
<p>阴影这块是我们项目目前要研究的重点内容之一，我们在考虑全部动态阴影的方案来部分替代烘焙的LightMap。这部分市面上的产品只观察到韩国的两款Unreal的手游这么来做，之前在网易内部使用Forward Lighting一直都是烘焙的方案。这块如果有朋友了解什么信息还希望不吝赐教~</p>
<h2 id="5-资源的同步和异步加载"><a href="#5-资源的同步和异步加载" class="headerlink" title="5. 资源的同步和异步加载"></a>5. 资源的同步和异步加载</h2><p>这是比较有意思的一块内容，之前的思路一直都是大部分情况下统一使用异步加载，只有在明确知道资源非常小，而且不重要的模块使用同步加载的方案，比如一个只有几个面的dummy model之类的。</p>
<p>UWA给出的建议是：在Loading界面中，如果需要表现平滑的加载进度和加载界面的话，可以使用同步加载，其他的过程中使用异步加载。原因是——</p>
<blockquote>
<p>”我们观察到，在对于同一个资源，同步加载比异步加载所花费的时间要少很多。异步加载会把任务拆分成比较小的粒度到每帧执行，但是在设备上每帧33ms的时间中，往往用不了这么久异步加载任务就执行完毕了，比如16ms甚至更少的时间，这就导致了无谓的等待。”</p>
</blockquote>
<p>如果觉得加载时间过长，而对于加载过程中的玩家体验不需要过多关注的项目可以参考这一思路。这的确是我之前的经验所没有包含的部分。</p>
<p>另外，在Unity中，对于异步加载来说，也可能会造成顿卡，因为不是所有的过程都是异步的。IO部分可以做到完全异步，但是内存中的初始化的部分过程可能仍然是同步的，比如一张1024<em>1024大小的贴图异步加载，通常设备上都会可以感受到卡顿，因此建议<em>*大于这个尺寸的贴图统一进行预加载</em></em>。</p>
<p>与此相关的还有一个Unity的小知识。Unity默认每帧给2ms的时间让CPU拷贝内存东西到GPU中，比如贴图、网格顶点等，默认的Buffer是4M大小，因此这里也会影响资源加载到最终渲染到屏幕上的时间。这两个参数是可以调整的，具体接口参考官方文档。另外默认4M正好是一张32位的1024<em>1024大小的贴图大小，如果使用了2048</em>2048或者更大的贴图格式，这个Buffer会增大为对应的大小，并且不会在缩小回来。因此建议资源中的最大尺寸可以给一个定义，尽量不要出现只有偶尔几张贴图使用非常大的尺寸的情况。</p>
<h2 id="6-动画模块的优化"><a href="#6-动画模块的优化" class="headerlink" title="6. 动画模块的优化"></a>6. 动画模块的优化</h2><p>除了常规的降低骨骼数量和动画曲线数量之外，Unity 5.2之后提供了一个culling Group的功能，用在模型位置一直绑定一个球的方式做碰撞体来优化判定，不在视锥范围的的物体不进行Animator的Update。这一功能主要针对脚本逻辑的Update，Animator没有提供单独的接口根据距离来控制Update频路，一个可行的思路是自己重写其Update接口，然后传入更高的Delta Time来模拟降频的功能。不过以我之前用Havok的降频功能来做性能对比的话，除非角色数量非常高，否则这部分骨骼骨骼的更新的优化空间不是非常大，不过Unity这块具体的数据要进行测试才知道。</p>
<p>Animator中有一个Optimize Game Objets的选项，可以降低Update的消耗，UWA建议使用。这是因为默认情况下每根骨骼都是一个GameObject，每帧骨骼更新之后会需要修改它们的Transform。</p>
<blockquote>
<p>“当打开这个选项，导入的角色中的游戏对象transform hierarchy将会被移除，而且以Avatar and Animator组件替代。<br>角色的SkinnedMeshRenderer将会直接使用Mecanim内部骨骼，因此我们能摆脱所有用于描述骨头的Transform。<br>这个选项将提升动画角色的性能，推荐最终产品开启这个选项。优化模式下，皮肤网格模型的抽取也是多线程的。<br>当开启了这个选项，用户能在ModelImporter inspector中指定“Extra Transforms to Expose”的列表。例如，如果你想附加一把剑道右手，这是一个挂载点。暴露的transform在游戏对象的hierarchy中是平行的，不管它在骨架视图中的深度”</p>
</blockquote>
<p>对于Animator的Active和Deactive的操作有很大的性能消耗，这在之前斗鱼上的直播中已经提到过了，这里还是像ui一样，建议将角色移出视窗之外的方式来进行缓存，或者只把组件Active和Deactive，来提升性能。</p>
<h2 id="7-其他的小tips"><a href="#7-其他的小tips" class="headerlink" title="7. 其他的小tips"></a>7. 其他的小tips</h2><p>除了上述的一些问题之外，还有一些比较了零碎的笔记，不进行赘述，只记录如下：</p>
<blockquote>
<ul>
<li>渲染面数建议控制在10w面一下，这是目前经过大量测试性价比比较高的一个点，5w-10w面测试看下来差别不是很大，Draw Call数量建议控制在200-300以内，比较好的情况是在100以下。</li>
<li>粒子系统通常需要加载的资源很多，但是初始化过程比较消耗CPU，因为通常一个粒子系统中的Component很多，建议进行预加载。</li>
<li>粒子系统中的PreWarn选项会在后台进行一次完整周期的模拟，因此使用可能会有卡顿。</li>
<li>Skined Mesh引擎是不会进行合并的，MeshBaker插件可以减低Draw Call数量，对于动态的物体也可以，但是会影响裁剪，而且动态添加和删除很慢，通常用于ARPG游戏中的优化，MMO较为少用。</li>
<li>注意创建Mesh和Material的拷贝过程，比如修改一个Material的参数，会创建一个新的Material对象，频繁地执行这样的操作会有泄漏出现，推荐使用DynamicMaterial，缓存然后只修改这一个动态材质的方法。</li>
</ul>
</blockquote>
<h2 id="8-大世界场景拆分和动态加载"><a href="#8-大世界场景拆分和动态加载" class="headerlink" title="8. 大世界场景拆分和动态加载"></a>8. 大世界场景拆分和动态加载</h2><p>这一部分是张强同学做的讲座，基于地形的方式实现了的大世界动态加载功能。其实这部分本来是我期望去听和讨论的部分，以为我们项目正好在进行这块的技术预研，但是我们不是使用地形，而是基于静态Mesh，另外视角我们更倾向于平视而非2.5D，因此这部分对于我们的帮助没有想象中的大。</p>
<p>我个人觉得这部分的一个问题是整个工程是基于一个Demo性质的实现，而非正式的项目，因为时间关系没有在后面进行深入的交流，因此也不清楚目前的实现是否在正式的项目中应用了。一些应用方面的疑问其实讲座正文中没有讲到：</p>
<blockquote>
<ul>
<li>结合到美术制作，地块的拆分建议遵循的原则是什么？比如多少个屏幕范围划分为一块比较合理？</li>
<li>如果使用lightmap的方案，两个地块交接处是否会有问题，比如交界处左侧有一座山，它的投影可能会在另外一个拆分后的地块上，如果拆分后再Bake，是否有解决方案可以处理这样的问题？</li>
<li>如果使用平视视角，目前有没有什么比较好的解决方案？LOD的话有哪些注意事项？</li>
</ul>
</blockquote>
<p>这部分可以直接参考官方给出的PPT，我做的笔记不太多，这里只放了一些没有来及提出的问题，幸好加了两位主持人的微信，回头整理好问题再一并请教，有答复了再修改本文。</p>
<h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>这次上海之行，一天时间往返上海杭州，只为了这两场讲座。从收获来说，虽然和预期稍有不同，但是还是很值得的。感谢张鑫博士和张强同学两位主持人的分享，你们辛苦啦~也感谢UWA公司组织这样免费的技术沙龙，祝愿贵公司越来越好~~</p>
<p>2016年11月27日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/性能优化/">性能优化</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/总结/">总结</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-unitydev1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/10/18/unitydev1/" class="article-date">
  	<time datetime="2016-10-17T16:11:50.000Z" itemprop="datePublished">2016-10-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/18/unitydev1/">Unity手游开发札记——Lua语言集成</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>2016年8月从网易“毕业”，在新的公司开始新的工作，这其中的波折与故事暂时不提，等以后有时间的时候再另开文章总结回顾。全新的手游项目从零开始，使用Unity引擎开发一款手游项目，本系列札记主要针对开发过程中重要的部分进行记录和总结，一方面方便自己日后回顾，也希望可以给遇到类似问题的朋友一些提醒和启发。当然，自己在Unity引擎和Lua语言方面都是新手，更加希望抛砖引玉，针对遇到的问题进行更广泛的讨论和更多大牛的提点。<br>具体到本篇文章的主题，主要是Lua语言和Unity引擎的集成。这是我最近一个月左右的时间一直在尝试解决的问题，本文主要记录方案的选择和对比，以及针对选择的方案自己进行的一些改造和思考。</p>
<h2 id="1-为什么要集成Lua语言"><a href="#1-为什么要集成Lua语言" class="headerlink" title="1. 为什么要集成Lua语言"></a>1. 为什么要集成Lua语言</h2><p>有句从知乎开始发展起来的名言叫做——“先问是不是，再问为什么”，类似地，在做一个技术方案的时候，“先问为什么，再考虑如何做”。那我们第一个问题就是要解决这个项目“为什么要集成Lua语言”？<br>在网易内部，一向遵守的传统是逻辑用脚本来做，比如Python、Lua等，好处主要有如下几点：</p>
<ul>
<li>利用脚本语言的动态特性，客户端可以做Hotfix，服务端可以做Refresh，无论在运营还是开发期这一特性都很有用；</li>
<li>脚本语言运行在虚拟机中，它把游戏进程搞挂的概率相比C/C++等静态语言要低；</li>
<li>脚本语言相对好学习一些，对于新手来说上手难度较低，比如Python，当然要精通也需要时间和经验的积累；</li>
</ul>
<p>当然还有其他的优点，对应的缺点就在于运行效率比C/C++低不少，相对于静态语言在编译器有完备的语法检查，动态语言更容易出一些运行时的错误，调试难度相对大一些。<br>而对于Unity引擎，因为它已经选择了C#作为对应的脚本语言，因此再集成一门Lua语言显得有些多余。核心的原因还是在IOS设备上因为使用了IL2CPP，无法实现像Android上面那样直接替换DLL的方式来进行更新，这导致游戏逻辑如果出现错误，不但无法Hotfix修复，甚至连Patch都不能修复，只能重新提包。虽然APP Store现在对于应用的审核速度已经变快， 但是仍然需要2-3天以上的时间，这对于需要快速反应的商业游戏来说是无法容忍的。<br>目前了解到的业内常用的做法主要有如下几种：</p>
<ul>
<li>纯C#开发的方式，比如腾讯这种大厂，某些工作室的做法就是完全使用C#来进行开发，尽量做到功能逻辑可配置，这样出现某些重大问题可以通过更新数据的方式把逻辑暂时关闭掉。逻辑的更新安卓使用替换DLL的方式，IOS使用重新提包的方式。对外测试以安卓为主，并且大厂有比较好的QA团队进行质量保证，因此可以做到IOS最终上线的品质和bug都是相对少的。</li>
<li>C#做核心逻辑，Lua做UI和活动玩法等执行频率低，需求变动较大的部分。这是目前了解到的一些创业团队使用得比较多的做法，在效率和可更新性之间的一个折中。</li>
<li>以Lua为主的方式。也了解到一些公司的团队，包括网易内部的一些项目，使用逻辑都以Lua语言来写的方式进行开发。从网易之前的经验来看，逻辑使用纯脚本的方式并不会有太大问题。</li>
</ul>
<p>我们要开发的产品是一款商业游戏，对于出现问题快速响应的需求相对强烈，因此在Unity中使用Lua语言是必不可少的，至于多大范围地应用它，初步是计划大部分功能都是用Lua语言来开发，并制定每隔一段时间周期进行性能测试和评估的方式来确保性能可以满足需求。</p>
<p>##2. 怎样集成Lua语言<br>在决定要使用Lua语言之后，要面临的问题就是如何在Unity中去集成它。可选的方案有很多，各种方案的实现原理也不尽相同，早期有各种在C#语言内部实现Lua虚拟机的，也有利用反射动态查找脚本的，但是目前比较主流的两种方案是<a href="https://github.com/topameng/tolua" target="_blank" rel="external">ToLua#</a>和<a href="https://github.com/pangweiwei/slua" target="_blank" rel="external">SLua</a>这两种方案。</p>
<h3 id="2-1-性能对比测试"><a href="#2-1-性能对比测试" class="headerlink" title="2.1 性能对比测试"></a>2.1 性能对比测试</h3><p>这两个方案的原理都相似，基于LUAInterface，在开发时将C#的接口导出为Lua的版本，通过LuaState的栈结构来进行两种语言之间方法调用。这两个开源项目针对性能对比在网上打了不少口水仗，到底谁更优秀很难公允地评价，因为作为一个中间件性质的开源项目，除了性能之外还有生态圈、易用性等各个方面的问题需要考量。网上有不少对比的帖子可以自己搜索一下，这里不进行详述了，以免引起论战。<br>在这一部分我们最终选择了ToLua#，原因我是自己在安卓设备上进行测试了结果。钱康来前段时间发了一个帖子来对比几款Unity中Lua集成方案的性能，<a href="http://qiankanglai.me/2016/07/31/unity-lua/" target="_blank" rel="external">Unity常见lua解决方案性能比较</a>，这篇文章也整理投稿到了<a href="http://blog.uwa4d.com/archives/lua_perf.html" target="_blank" rel="external">UWA博客</a>中，我自己基于测试用例在锤子T2上进行了简单的性能测试，结论和这篇博客中的基本一致，未整理的数据如下表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">框架</th>
<th style="text-align:center">test1</th>
<th style="text-align:center">test2</th>
<th style="text-align:center">test3</th>
<th style="text-align:center">test4</th>
<th style="text-align:center">test5</th>
<th style="text-align:center">test6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SLua</td>
<td style="text-align:center">755.004</td>
<td style="text-align:center">623.619</td>
<td style="text-align:center">34.126</td>
<td style="text-align:center">6812.41</td>
<td style="text-align:center">1648.68</td>
<td style="text-align:center">0.6352</td>
</tr>
<tr>
<td style="text-align:center">ToLua#</td>
<td style="text-align:center">634</td>
<td style="text-align:center">871.2</td>
<td style="text-align:center">297.8</td>
<td style="text-align:center">3056.2</td>
<td style="text-align:center">1139.4</td>
<td style="text-align:center">1.206</td>
</tr>
</tbody>
</table>
<p>数据的单位是毫秒，测试是进行五次测试的平均值，使用锤子T2进行。这次测试并不严谨，只是为了亲自验证一下两者之间的性能差异到底是什么样子的。每一个测试用例的代码可以参考前文提到文章，这里只简单进行说明：</p>
<ul>
<li>test1是简单的属性操作；</li>
<li>test2和test3是向量的操作；</li>
<li>test4是GameObject的创建；</li>
<li>test5是创建GameObject并进行一些属性操作；</li>
<li>test6是对四元数进行操作。</li>
</ul>
<h3 id="2-2-性能差异的可能原因之一"><a href="#2-2-性能差异的可能原因之一" class="headerlink" title="2.2 性能差异的可能原因之一"></a>2.2 性能差异的可能原因之一</h3><p>个人感觉ToLua#在属性操作方面性能较好，而Vector的向量操作，因为可能会有Lua层的优化，即在Lua层完全实现了对应的操作，因此需要针对源码进行详细的对比。至于性能差异的原因，我没有从Lua虚拟机的实现部分分析，只是查看两种生成Warp后的接口进行一个简单的猜想。<br>选取同一个接口进行对比，UnityEngine.Animator的GetFloat接口，ToLua#的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class="line">static int GetFloat(IntPtr L)</span><br><span class="line">&#123;</span><br><span class="line">	try</span><br><span class="line">	&#123;</span><br><span class="line">		int count = LuaDLL.lua_gettop(L);</span><br><span class="line"></span><br><span class="line">		if (count == 2 &amp;&amp; TypeChecker.CheckTypes(L, 1, typeof(UnityEngine.Animator), typeof(int)))</span><br><span class="line">		&#123;</span><br><span class="line">			UnityEngine.Animator obj = (UnityEngine.Animator)ToLua.ToObject(L, 1);</span><br><span class="line">			int arg0 = (int)LuaDLL.lua_tonumber(L, 2);</span><br><span class="line">			float o = obj.GetFloat(arg0);</span><br><span class="line">			LuaDLL.lua_pushnumber(L, o);</span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		//此处省略另一个重载接口</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			return LuaDLL.luaL_throw(L, &quot;invalid arguments to method: UnityEngine.Animator.GetFloat&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(Exception e)</span><br><span class="line">	&#123;</span><br><span class="line">		return LuaDLL.toluaL_exception(L, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> SLua生成的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]</span><br><span class="line">static public int GetFloat(IntPtr l) &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		int argc = LuaDLL.lua_gettop(l);</span><br><span class="line">		if(matchType(l,argc,2,typeof(int)))&#123;</span><br><span class="line">			UnityEngine.Animator self=(UnityEngine.Animator)checkSelf(l);</span><br><span class="line">			System.Int32 a1;</span><br><span class="line">			checkType(l,2,out a1);</span><br><span class="line">			var ret=self.GetFloat(a1);</span><br><span class="line">			pushValue(l,true);</span><br><span class="line">			pushValue(l,ret);</span><br><span class="line">			return 2;</span><br><span class="line">		&#125;</span><br><span class="line">		//此处省略另一个重载接口</span><br><span class="line">		pushValue(l,false);</span><br><span class="line">		LuaDLL.lua_pushstring(l,&quot;No matched override function to call&quot;);</span><br><span class="line">		return 2;</span><br><span class="line">	&#125;</span><br><span class="line">	catch(Exception e) &#123;</span><br><span class="line">		return error(l,e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，这一函数只需要一个返回值的，但是SLua往栈里pushValue了两个值，然后返回2，第一个值是一个bool值，它应该是用于标识函数调用是否成功。在不了解其他地方是否有性能差别的情况下，这里应该是ToLus#和SLua在简单的接口调用上的性能差别的原因之一。SLua使用一个单独的值来表示函数运行结果，这对于错误可以进行更好的处理，但是多出的压栈和出栈操作有额外的性能消耗。</p>
<h3 id="2-3-导出方式对比"><a href="#2-3-导出方式对比" class="headerlink" title="2.3 导出方式对比"></a>2.3 导出方式对比</h3><p>ToLua#导出使用的是白名单的方式，在CustomeSettings.cs文件中定义的接口才会导出，也提供了导出引擎所有的接口的功能；而SLua是以黑名单的方式进行，默认提供的功能是导出除了黑名单中的所有模块接口，也提供了一个导出最简接口的方式。<br>从使用角度来看，SLua黑名单的方式在开发期比较方便，默认会导出所有接口，因此不需要每次想要增加一个已经存在的类的Lua接口都要自己定义然后重新导出，发布的时候也可以使用最简接口的方式导出。维护起来ToLua#因为所有的导出类都是我们自己定义的，因此更加清晰明确。<br>鉴于这部分内容有源码可以进行修改，因此不是一个核心需要考虑的内容，两种方式各有利弊。</p>
<h3 id="2-4-我们的选择"><a href="#2-4-我们的选择" class="headerlink" title="2.4 我们的选择"></a>2.4 我们的选择</h3><p>至于这一点是否是性能差别的主要原因，因为没有时间和精力阅读其他部分的源码，暂时也不太好进行对比和评价。出于性能的考虑，我们项目决定使用ToLua#作为Lua部分集成的方案，并且以接口的形式进行封装，来保证后面替换的可能性。</p>
<h2 id="3-如何使用Lua语言"><a href="#3-如何使用Lua语言" class="headerlink" title="3. 如何使用Lua语言"></a>3. 如何使用Lua语言</h2><p>在进行了初步集成之后，怎样让开发人员可以更好地使用Lua语言是接下来要面临的问题。ToLua#对应有一套之前ulua作者开发的<a href="https://github.com/jarjin/LuaFramework_UGUI" target="_blank" rel="external">LuaFramework</a>，这一个框架集成了脚本打包和二进制脚本读取、UI制作流程等多个功能，但是也如作者自己所说，这一框架最初源自一个示例形式的Demo，因此其中代码有很多部分是和示例写死绑定的逻辑，比如启动逻辑、Lua二进制脚本的加载需要手动指定等等。<br>相对应的，SLua也有多套已经开源的框架，其中最为完善的是<a href="https://github.com/mr-kelly/KSFramework" target="_blank" rel="external">KSFramwork</a>，这套框架集成了资源打包、导表、Lua热重载在内的多个功能，而且代码质量初步看起来还不错，因此最终我们决定把KSFramwork中的SLua部分替换成ToLua#的部分来结合使用。<br>改造的过程还比较简单，由于该部分使用Lua耦合的只有两块内容，一是UIControler部分，二是LuaBehavior部分，所有的接口都由LuaModule模块提供。因此改造的过程也就比较明确了：</p>
<ol>
<li>删除源代码中的SLua部分，接入ToLua#的部分；</li>
<li>使用ToLua#重写LuaModule的实现；</li>
<li>改造LuaUIController，使用新的LuaModule接口实现之前的功能；</li>
<li>改造LUABehavior模块。</li>
</ol>
<p>代码删除和LuaModule模块的重新实现都比较简单，着重介绍一下LuaUIController和LUABehavior模块的改造。</p>
<h3 id="3-1-改造初衷"><a href="#3-1-改造初衷" class="headerlink" title="3.1 改造初衷"></a>3.1 改造初衷</h3><p>之前的KSFramwork还是一个核心逻辑在C#，Lua只承载UI等逻辑的模块，这与我之前从网易“继承”的“轻引擎，重脚本”的思路并不契合。在这一思路下，引擎可以看做渲染、资源加载、音效等功能的提供者，脚本逻辑负责使用这些功能构建游戏内容。那这样大部分与逻辑相关的控制权就应该从引擎交给脚本部分来进行。Unity作为一个比较特殊的例子，虽然对于它来说，C#部分已经是脚本了，但是对于希望着重使用Lua脚本的我们来说，因为C#不可更新，因此被视作了引擎部分。<br>最为简单的设计就是当引擎初始化完毕之后，通过一个接口调用把后续的逻辑都交由脚本来控制，大部分与游戏玩法相关的模型加载、声音播放、特效播放、动画播放等由脚本来控制。tick逻辑为了减少调用次数，每帧也由引擎调用注册的一个脚本接口进行统一调用，脚本层自己做分发。</p>
<h3 id="3-2-LuaUIController的改造"><a href="#3-2-LuaUIController的改造" class="headerlink" title="3.2 LuaUIController的改造"></a>3.2 LuaUIController的改造</h3><p>LuaUIController原始的方式是在C#层通过ui模块的名称加载对应的一个lua文件，获取一个lua table进行缓存，在比如OnInit等需要接口调用的地方查找这个table中对应的函数进行调用。这种方式的界面是由C#层的逻辑来驱动加载和显示的，而且在加载过程中要有文件的搜索和检查过程。<br>这样会存在一个问题，就是脚本层的逻辑无法或者很难去控制界面对象的生命周期。针对资源的生命周期，“<strong>谁创建谁管理</strong>”的策略不再可以很方便地来明确责任的划分，因此要进行改造。<br>改造的方向很简单，将界面加载和显示的接口开放到Lua层，然后在创建的时候由lua层传递一个table对象进来，C#中进行缓存，当界面资源异步加载完毕，需要进行接口调用的地方的实现与之前保存一致。这样，界面资源的生命周期全部交由脚本层来管理，在脚本构建一个结构合理功能齐全的UIManager来进行一些功能的封装，就可以满足大部分的需求。</p>
<h2 id="3-3-LuaBehavior的改造"><a href="#3-3-LuaBehavior的改造" class="headerlink" title="3.3 LuaBehavior的改造"></a>3.3 LuaBehavior的改造</h2><p>MonoBehavior是Unity为了放便开发而提供的一个很好的功能，脚本以组件的方式挂接在GameObject身上，就可以在Awake、Start、Update等接口中处理想要的逻辑。为了能够继续使用Unity的这一特性，在Lua层也实现了一个简单的LuaBehavior封装。<br>KSFramwork中的思路非常简单，同样根据名称来把一个LuaBehavior和一个Lua脚本进行绑定，在对应的逻辑中调用与之对应的接口就可以了。比如Awake接口的实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected virtual void Awake()</span><br><span class="line">&#123;</span><br><span class="line">    if (!string.IsNullOrEmpty(LuaPath))</span><br><span class="line">    &#123;</span><br><span class="line">        Init();</span><br><span class="line">        CallLuaFunction(&quot;Awake&quot;);</span><br><span class="line">    &#125; // else Null Lua Path, pass Awake!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>CallLuaFunction</code>的实现也很明确，从缓存的lua table中获取名称为Awake的function进行调用。这种方式没有问题，但是当场景中挂载了LuaBehavior的GameObject很多的时候，每一帧都会有非常多次的update方法调用，这个调用从C#层传递给Lua层，有很多额外的性能消耗。<br>前文也提到了，比较好的方式是每帧只有一个C#到Lua层的Update方法调用，然后脚本层自己做分发。因此，针对这一需求，我们使用ToLua#自带的LuaLooper来实现这一功能。<br>LuaLooper是全局只创建一个的MonoBehaviour，注意这里只创建一个是由逻辑来决定的，而不是一个单例模式。这里针对单例模式适用场合的讨论不再展开，此处由逻辑来保证只有一个Looper存在是一件比较合理的事情，预留了一些扩展的可能。<br>LuaLooper以事件的方式将三种Update分发出去：Update、LateUpdate、FixedUpdate，它在自己对应的函数中调用luaState的对应函数来将事件告知脚本，脚本中需要的模块向分发模块注册回调来监听事件，就可以做到每帧只有一次Update调用了。<br>具体的代码实现可以去看ToLua#中的LupLooper.cs的类实现。</p>
<blockquote>
<p><strong>注意</strong> 这里有一个需要小心的点是当事件在脚本层分发的时候，要注意执行时序问题的影响，最好能够保证任意的执行顺序都可以不影响游戏逻辑的结果，否则可能会出现很难查的诡异bug。</p>
</blockquote>
<p>对于Awake、Start等一次性调用的函数，由于不是频繁的逻辑，因此保留了原始的实现方式，这样可以让Lua层对应的代码实现更加简洁。而使用事件注册的方式，让不需要update逻辑的脚本没有任何额外的性能消耗。</p>
<h2 id="4-结语"><a href="#4-结语" class="headerlink" title="4. 结语"></a>4. 结语</h2><p>只有上述的这些部分，对于开发一款商业游戏来说还远远不够，但是通过导出的接口和对于KSFramwork的一些改进，已经可以实现一个简单的由Lua层来驱动的Demo了，它可以加载场景，打开一个打包成AssetBundle的界面，设置界面上的控件属性，为按钮添加一些回调时间，然后切换场景，加载一些打包在AssetBudnle中的Prefab模型。<br>这是Lua初步集成的结束，也是在这款游戏中创造万物的开始。</p>
<p>2016年10月18日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Lua/">Lua</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance6" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/11/pythonadvance6/" class="article-date">
  	<time datetime="2016-07-10T16:06:50.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/pythonadvance6/">Python进阶(六)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在讨论完Callable相关的部分之后，我们继续来看一下Class相关的两个东西——Property和super。</p>
<h2 id="9-Property"><a href="#9-Property" class="headerlink" title="9. Property"></a>9. Property</h2><p>这部分其实比较简单，属于Python的基本内容，也是工作中经常用到，比如做属性封装，在属性访问的时候添加一些自己想要做的事情。直接看一个简单的代码例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b)</span>:</span></span><br><span class="line">		self._a = a</span><br><span class="line">		self._b = b</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_get_a</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._a</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_set_a</span><span class="params">(self, a)</span>:</span></span><br><span class="line">		self._a = a</span><br><span class="line">	a = property(_get_a, _set_a)</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_get_b</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._b</span><br><span class="line">	b = property(_get_b)</span><br><span class="line">	</span><br><span class="line">a = A(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">a1 = A.a</span><br><span class="line">a2 = A.a</span><br><span class="line">a3 = a.a</span><br><span class="line">a4 = a.a</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> id(a1), id(a2), id(a3), id(a4), id(a._a)</span><br><span class="line"><span class="keyword">print</span> a1, a2, a3, a4</span><br><span class="line"><span class="keyword">print</span> a1.fget, a1.fset</span><br></pre></td></tr></table></figure></p>
<p>输出结果为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">39712928</span> <span class="number">39712928</span> <span class="number">39745760</span> <span class="number">39745760</span> <span class="number">39745760</span></span><br><span class="line">&lt;property object at <span class="number">0x025DF8A0</span>&gt; &lt;property object at <span class="number">0x025DF8A0</span>&gt; <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&lt;function _get_a at <span class="number">0x02C677F0</span>&gt; &lt;function _set_a at <span class="number">0x02C677B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们担心会有类似bound method或者unbound method的机制，所以尝试用两个变量来保存A.a和a.a，发现他们的id并不会变化，说明它们在Ptyhon中是一个稳定的对象，而非在需要是动态创建的。当然，A.a和a.a并不是同一个对象，把他们分别输出出来就可以看到，A.a是一个property对象，而a.a直接访问到了a对象身上的_a属性。通过id方法可以看到a3、a4和a._a其实是一同一个对象。<br>关键词property其实是一个class，当访问它的时候，代理对象会用对应的方法进行替换，支持的方法包括fget、fset和fdel。</p>
<h2 id="10-super"><a href="#10-super" class="headerlink" title="10. super"></a>10. super</h2><p>对于super这个关键词的使用其实算是Python的基础知识了，我们从一个简单的例子来探究一下，Python为什么从2.2版本加入这个关键词，它的使用带来我们什么样的便利和困扰？<br>先来看最为简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in A'</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in B'</span></span><br><span class="line">		A.__init__(self)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in C'</span></span><br><span class="line">		super(C, self).__init__()</span><br><span class="line">		</span><br><span class="line">b = B()</span><br><span class="line">c = C()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> super(A, c)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in B</span><br><span class="line">in A</span><br><span class="line">in C</span><br><span class="line">in A</span><br><span class="line">&lt;super: &lt;class 'A'&gt;, &lt;C object&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<p>结果很简单，无需过多的解释，输出的信息显示了构造的过程，唯一需要指出的是super是一种buildin class。那么它是怎样工作的呢？也就是构造B的时候是如何确定它要调用到的父类方法的呢？<br>在C++中，有虚函数表的结构，用于实现继承中动态多态的特性。在Python中，有<code>__mro__</code>属性来描述继承关系。什么是mro呢？mro是method resolution order，直译是“方法解决顺序”，但是这个不能很好地表达英文原文的含义，简单来说Python用它来解析方法的调用顺序。我们通过具体的例子来看一下。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in A'</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(B, self).__init__()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">b = B()     <span class="comment"># in A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> B.__mro__     <span class="comment"># (&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到<code>B.__mro__</code>是一个元组，记录了对于B这个类来说的继承关系。在运行时，当调用<code>b.foo</code>方法的时候，会按照mro的顺序去依次查找含有此方法定义的对象或者类，直到找到为止，或者未找到会报错。注意这个过程是在<strong>运行时</strong>的，而非编译时，这也是python方法调用比较慢的原因之一。<br>super关键字也是通过这个数据结构来进行方法调用的，不同的是原理上，在存在的前提下，它会依次调用整个mro结构上的类上对应的方法。</p>
<blockquote>
<p><strong>思考</strong>：<code>__mro__</code>存在在哪里？</p>
</blockquote>
<p>看上去mro属性是一个数据，它似乎应该存储在B的身上，但是我们查看B的<code>__dict__</code>属性的时候发现其中并没有<code>__mro__</code>这个名称。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(B)</span><br><span class="line"><span class="comment"># ['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'foo']</span></span><br></pre></td></tr></table></figure></p>
<p>似乎又有神奇的事情发生了，<code>B.__mro__</code>是如何访问到的呢？我们知道，在没有定义metaclass的情况下，所有的类对象（<strong>类对象，并非类实例对象</strong>）都是一个type对象，那我们来用dir看一下type：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> dir(type)</span><br><span class="line"><span class="comment">#['__abstractmethods__', '__base__', '__bases__', '__basicsize__', '__call__', '__class__', '__delattr__', '__dict__', '__dictoffset__', '__doc__', '__eq__', '__flags__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__instancecheck__', '__itemsize__', '__le__', '__lt__', '__module__', '__mro__', '__name__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasscheck__', '__subclasses__', '__subclasshook__', '__weakrefoffset__', 'mro']</span></span><br></pre></td></tr></table></figure></p>
<p>Bingo！不但有<code>__mro__</code>，还有一个mro属性。<br>这里关于为什么放在type里，有一个stackoverflow的讨论可以参考下，本文不进行详述了：<br><a href="http://stackoverflow.com/questions/16663514/why-does-mro-not-show-up-in-dirmyclass" target="_blank" rel="external">Why does <strong>mro</strong> not show up in dir(MyClass)?</a></p>
<p>接着我们来回答第一个问题——Python为什么从2.2版本加入这个关键词？<br>在更早的版本中，当调用父类方法的时候，比如上面B继承自A的例子，需要手动调用<code>A.__init__(self)</code>，这样在需要重构A的时候，比如修改名称等，需要把所有继承自A的类中的代码都进行修改，这其实是不合理的一种设定。因此引入了super关键词处理这个过程，同时也为了实现super的功能添加了mro的结构。<br>在单继承结构下，mro可以很好的工作，多继承的情况下会否有什么问题呢？依然看一个简单的例子，C继承自A和B：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'enter A'</span></span><br><span class="line">		<span class="comment"># super(A, self).__init__()</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'level A'</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'enter B'</span></span><br><span class="line">		<span class="comment"># super(B, self).__init__()</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'level B'</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A, B)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">print</span> <span class="string">'in C'</span></span><br><span class="line">		super(C, self).__init__()</span><br><span class="line">		</span><br><span class="line">c = C()</span><br><span class="line">m = c.foo</span><br><span class="line"><span class="keyword">print</span> C.__mro__</span><br><span class="line"><span class="keyword">print</span> m.im_func, A.foo.im_func, B.foo.im_func</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">in C</span><br><span class="line">enter A</span><br><span class="line">level A</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;)</span><br><span class="line">&lt;function foo at 0x029478B0&gt; &lt;function foo at 0x029478B0&gt; &lt;function foo at 0x02947830&gt;</span><br></pre></td></tr></table></figure></p>
<p>不太对哦，按照我们想要的结果，应当是通过super可以调用到父类A和父类B中的初始化方法才对！但是结果只调用到了A的，为什么？<br>细心的读者已经发现了，A和B中注释掉了两行super相关的代码，把它们的注释取消掉，输出结果就变成了：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in C</span><br><span class="line">enter A</span><br><span class="line">enter B</span><br><span class="line">level B</span><br><span class="line">level A</span><br><span class="line">(&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;, &lt;type 'object'&gt;)</span><br><span class="line">&lt;function foo at 0x02A37930&gt; &lt;function foo at 0x02A37930&gt; &lt;function foo at 0x02A378B0&gt;</span><br></pre></td></tr></table></figure></p>
<p>这样就可以调用到了A和B的初始化方法，注意，这里的调用过程是<strong>嵌套</strong>的。具体这是为什么，我这里偷懒，请参考关于super的经典文章：<a href="https://rhettinger.wordpress.com/2011/05/26/super-considered-super/" target="_blank" rel="external">Python’s super() considered super!</a>，或者参考知乎的问题讨论：<a href="https://www.zhihu.com/question/20040039" target="_blank" rel="external">Python中既然可以直接通过父类名调用父类方法为什么还会存在super函数？</a></p>
<blockquote>
<p><strong>结论</strong>：super基于mro可以处理多重继承的调用关系，按照拓扑结构来进行，同层继承中遵守从左到右的继承顺序。<strong>但是</strong>，要注意所有的父类方法都正确使用super来进行调用，<strong>即使是直接继承自object的对象</strong>！否则可能产生方法调用不到的现象。</p>
</blockquote>
<p>需要额外指出的是，对于参数数目或者类型不同的情况，通过super的调用可能会导致trace，比如下面的例子就会有错误。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">		super(B, self).__init__(p1)</span><br><span class="line">		</span><br><span class="line">b = B(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> b</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		super(C, self).__init__(<span class="number">0</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B, C)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, p1, p2)</span>:</span></span><br><span class="line">		super(D, self).__init__(p1, p2)</span><br><span class="line">		</span><br><span class="line">d = D(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> D.__mro__</span><br></pre></td></tr></table></figure></p>
<p>在原本A、B和C的继承结构可以正常工作的情况下，加入D，就会导致TypeError，解决的方法只能是按照最多的参数或者dict这种容器来设计函数的参数以兼容多种情况。</p>
<blockquote>
<p><strong>总结</strong>：在Python中，即使引入了super关键字和mro的机制来处理继承的情况，对于复杂的多重继承甚至菱形继承，还会出现很多问题，包括维护上和运行时的问题，因此本质上还是使用类似面向接口编程的方式来从根本上避免这种问题更好。</p>
</blockquote>
<p>PS：关于Python进阶的问题已经写了六篇了，在整理记录的过程中，我发现了一些听课时没有考虑过的新问题，也通过阅读其他的文档掌握新的知识，在简书上也收到了不少喜欢和关注。感谢引导我学习给我们讲课的同事大雄，然后感谢每一个阅读的读者，你有收获或者思考，我们彼此花的时间就都值得了。<br>关于基本的语言特性部分基本就包括上面的1-10个小节的内容，后面的课程内容关于gc和C++绑定等部分的，看时间慢慢整理。</p>
<p>2016年7月11日凌晨于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance5" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/10/pythonadvance5/" class="article-date">
  	<time datetime="2016-07-10T13:03:25.000Z" itemprop="datePublished">2016-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/10/pythonadvance5/">Python进阶(五)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="7-Function"><a href="#7-Function" class="headerlink" title="7. Function"></a>7. Function</h2><p>作为Callable部分第一个被提到，但是最后来分析它。原因其实很简单，我们已经发现前面的很多内容，包括bound method也好，static method也好，甚至operators，本质上都是function。<br>那么，如何去探究一个Python的Function的属性呢，阅读过前面内容的读者应该很明白了，通过一些简单的代码加上print就可以看到不少东西了。<br>我们先用dirf来看下一个function对象身上有什么。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b = <span class="number">10</span>)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(foo)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'func_closure'</span>, <span class="string">'func_code'</span>, <span class="string">'func_defaults'</span>, <span class="string">'func_dict'</span>, <span class="string">'func_doc'</span>, <span class="string">'func_globals'</span>, <span class="string">'func_name'</span>]</span><br></pre></td></tr></table></figure></p>
<p>不管双下划线开头的部分属性，我们只看对外开放的部分，先来看一看func_name属性吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> foo       <span class="comment">#&lt;function foo at 0x0235A2B0&gt;</span></span><br><span class="line">foo.func_name = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">print</span> foo       &lt;function abc at <span class="number">0x0235A2B0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>func_name看上只是用来记录信息的一个名称而已，修改它并不会影响函数对象的调用。<br>我们再来看下func_defaults属性，看名称它是和默认值相关。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="number">1</span>)			<span class="comment">#11</span></span><br><span class="line"><span class="keyword">print</span> foo.func_defaults		<span class="comment">#(10,)</span></span><br><span class="line">foo.func_defaults = (<span class="number">100</span>, )</span><br><span class="line">foo(<span class="number">1</span>)			<span class="comment">#101</span></span><br></pre></td></tr></table></figure></p>
<p>依然是把输出的结果放在代码行的后面以注释的形式给出，我们看到函数对象的func_defaults属性是一个元组，依次列出了所有默认参数。我们可以通过改变这个属性来改变已经被定义了的函数的默认参数。<br>为了可以看到func_closture的内容，我们构建一个闭包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> x + n</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">	</span><br><span class="line">f = bar(<span class="number">1</span>)</span><br><span class="line">g = bar(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">print</span> f(<span class="number">2</span>)		<span class="comment"># 3</span></span><br><span class="line"><span class="keyword">print</span> g(<span class="string">"def"</span>)	<span class="comment"># defabc</span></span><br><span class="line"><span class="keyword">print</span> foo.func_closure	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> f.func_closure	<span class="comment"># (&lt;cell at 0x029655F0: int object at 0x029378E0&gt;,)</span></span><br><span class="line"><span class="keyword">print</span> g.func_closure	<span class="comment"># (&lt;cell at 0x02A31130: str object at 0x02972AE8&gt;,)</span></span><br></pre></td></tr></table></figure></p>
<p>f和g是两个闭包对象，可以看到foo这个函数对象身上的func_closure属性为None，f和g身上分别是两个cell对象，这部分内容和闭包中讲的部分就契合在了一起。<br>func_code属性我们也来看一下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">print</span> a * b</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> bar.func_code</span><br><span class="line"><span class="keyword">print</span> dir(bar.func_code)</span><br><span class="line"></span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line">foo.func_code = bar.func_code</span><br><span class="line">foo(<span class="number">6</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>输出的结果由于比较长，写在了下面：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;code object bar at <span class="number">02516</span>C80, file <span class="string">"C:\Users\David-PC\Desktop\Advanced Course on Python 2016\a014.py"</span>, line <span class="number">27</span>&gt;</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__cmp__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'co_argcount'</span>, <span class="string">'co_cellvars'</span>, <span class="string">'co_code'</span>, <span class="string">'co_consts'</span>, <span class="string">'co_filename'</span>, <span class="string">'co_firstlineno'</span>, <span class="string">'co_flags'</span>, <span class="string">'co_freevars'</span>, <span class="string">'co_lnotab'</span>, <span class="string">'co_name'</span>, <span class="string">'co_names'</span>, <span class="string">'co_nlocals'</span>, <span class="string">'co_stacksize'</span>, <span class="string">'co_varnames'</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，func<em>code是一个code object，它有的属性有很多，基本以co</em>开头，如果有兴趣，可以自己一点点去把他们print出来看，也可以发现很多有趣的东西，这里暂时不进行展开。例子的另外一部分展示了func_code是可以被替换的。</p>
<blockquote>
<p><strong>扩展</strong>：关于code对象，可以阅读<a href="https://late.am/post/2012/03/26/exploring-python-code-objects.html" target="_blank" rel="external">Exploring Python Code Objects</a>，了解怎样通过compile方法来生成code object，以及code类的一些属性。</p>
</blockquote>
<p>关于function中比较重要的几个属性，以表格的形式总结出来。<br>| 属性名称      | 描述   |<br>| ——–      | —–:  |<br>| func_name     | 函数名称 |<br>| func_defaults |   函数的默认值列表   |<br>| func_code     |    函数体的code对象    |<br>| func_globals  |  函数的全局命名空间 |<br>| func_closure  | 函数的cell对象 |<br>看了function的这些属性，对于之前讨论过的hotfix是不是有了更深的了解呢？只需要替换一个函数对象的func_code，func_defaults，func_closure等属性，这个函数的行为就可以被改变了，结合上bound method和unbound method的动态生成的特性，对Python语言的动态性的原理的理解是否有更深入了一步呢？</p>
<h2 id="8-Classes"><a href="#8-Classes" class="headerlink" title="8. Classes"></a>8. Classes</h2><p>关于类，其实有很多可以讨论的内容，从生命周期的角度来看，一个C++类的对象包含如下四个生命周期：</p>
<ol>
<li>内存分配，malloc</li>
<li>调用构造函数初始化对象，A::A()</li>
<li>调用析构函数清理对象，A::~A()</li>
<li>释放内存，free</li>
</ol>
<p>不同的编译器在内存分配或者释放的时候具体使用的函数可能不同，但这四个步骤是都有的，而且在C++中，1和4两个步骤是隐式的，即开发者通常不需要去关心（当然也有可以去操作的方法），它们分别隐含在了构造函数和析构函数当中。<br>对于Python的对象来说，其生命周期包含如下三个部分：</p>
<ol>
<li>内存分配，<code>__new__</code>方法；</li>
<li>调用初始化(initializer)，<code>__init__</code>方法；</li>
<li>调用终结器(finalizer)，<code>__del__</code>方法；</li>
</ol>
<p>对于自定义的类，上述的过程可以通过重载对应的方法来实现对于其过程的控制。可以看到，这里并没有内存释放的过程，也就是说开发者无法主动控制对象所占用过的内存的释放，这一部分是方便开发者不需要进行内存的管理，另外也利于Python语言本身进行对象缓存池的设计与实现。这部分内容在bound method的部分已经看到了缓存池在Python的应用，更多的讨论放在内存管理的部分来进行。</p>
<blockquote>
<p><strong>思考</strong>：Python中如何实现单例模式？是否可以通过重载<code>__new__</code>方法，在每次分配内存的时候返回同一个对象来实现呢？</p>
</blockquote>
<p>答案是否定的，因为Python对于生命周期的控制决定了在<code>__new__</code>方法被调用，内存分配完毕之后会主动调用<code>__init__</code>方法，这样虽然分配的是同一个对象，但是多次<code>__init__</code>方法的调用可能会导致对象的属性被修改，可能会引发意料之外的bug，比如已经被修改过属性又被<code>__init__</code>方法改变等。</p>
<p>说了这些之后，对于Class我们返回Callable的主题，Python中的Class也是一个Callable的对象，调用一个类的结果很简单，就是获得一个类的实例化对象，我们来看一个简单的例子。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> Foo 				<span class="comment"># &lt;class '__main__.Foo'&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo.__call__		<span class="comment"># &lt;method-wrapper '__call__' of type object at 0x029D33E0&gt;</span></span><br><span class="line"><span class="keyword">print</span> Foo()				<span class="comment"># &lt;__main__.Foo object at 0x02AAEED0&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> func.__call__		<span class="comment"># &lt;method-wrapper '__call__' of function object at 0x029C77F0&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>类Foo是一个class对象，它是可以访问到<code>__call__</code>属性的，它是一个id为0x029D33E0的type对象的’<strong>call</strong>‘方法的method-wrapper，如果打印<code>print id(Foo)</code>的话，你可以发现它的十六进制结果就是0x029D33E0。这容易理解，而对于method-wrapper，我把它理解为一个方法的封装。查了一些资料，但是没有找到官方的精准答案，这里我猜测对象的创建、函数的执行等过程，在Python中可能是一种C的实现，因此在Python层给出的是一个wrapper，可以让他们的行为像一个Python的函数一样。当然这是我的猜测，如果有知道准确答案的朋友欢迎指导。</p>
<blockquote>
<p><strong>思考</strong>：Class作为一个Callable的类型，对于我们开发中有什么好处吗？</p>
</blockquote>
<p>想象一下工厂方法在C++中的实现，通常需要通过一个函数来封装一个对象的创建过程，而在Python中，我们可以把对象类型存储在一个字典或者列表中，通过映射关系，可以直接生成对象。某种程度上说，这也是一种“反射”机制。具体的代码由于比较简单，此处就不列举了。</p>
<blockquote>
<p><strong>总结</strong>：关于Callable的部分已经聊得差不多了，从我们分析的过程看，我们通常使用dir和print在加上一些分析能力就可以看出Python语言设计上的一些原理和思路，一切皆对象的理念被应用的淋漓尽致，而为了实现其动态特性，Python语言做了很多特殊的设计和方法。</p>
</blockquote>
<p>2016年7月10日于杭州家中</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance4" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/09/pythonadvance4/" class="article-date">
  	<time datetime="2016-07-09T00:42:42.000Z" itemprop="datePublished">2016-07-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/09/pythonadvance4/">Python进阶(四)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5-Class-method和Static-method"><a href="#5-Class-method和Static-method" class="headerlink" title="5. Class method和Static method"></a>5. Class method和Static method</h2><p>这部分其实不能算Python的进阶内容了，可以说是基础内容。在初学Python的时候我就有过一些疑惑，<code>@classmethod</code>和<code>@staticmethod</code>修饰的函数看上去似乎没有什么区别，都是通过类来调用（当然对象也可以）。本小节内容稍微看一下两者的区别，首先是class method，因为比较简单，直接看代码例子和结果吧。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">&lt;bound method type.foo of &lt;class '__main__.A'&gt;&gt;</span><br><span class="line">1 37346800</span><br><span class="line">2 37266616</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们把<code>A.foo</code>打印处理，是一个bound method对象，通过对象a来访问也是一样的，我们学着bound method的方式来分析看，m1和m2的id是不同，在理解了第4小节的内容之后这里就比较容易理解了。</p>
<blockquote>
<p><strong>思考</strong>： Class method是绑定了什么东西的bound method呢？</p>
</blockquote>
<p>通过查看bound method对象的im_self属性就可以看到它所绑定的对象了，我们添加一些代码来分析。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> m1.im_self</span><br><span class="line"><span class="keyword">print</span> m2.im_self</span><br><span class="line"></span><br><span class="line">m3 = a.bar</span><br><span class="line"><span class="keyword">print</span> m3.im_self</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;class '__main__.A'&gt;</span><br><span class="line">&lt;__main__.A object at 0x02440030&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>结论</strong>： Class Method是绑定了类对象的bound method。</p>
</blockquote>
<p>需要<strong>额外注意</strong>的是，<code>def foo(self):</code>这里对于class method的定义是不好的，具有一定的误导性，这里的self不再是类的实例对象了，而是一个class对象，因此通常写成<code>def foo(cls):</code>或者<code>def foo(klass)</code>更清晰。</p>
<p>Static method是否也是bound method呢？我们直接来看分析代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">	@staticmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">print</span> A.foo</span><br><span class="line"><span class="keyword">print</span> a.foo</span><br><span class="line"></span><br><span class="line">m1 = A.foo</span><br><span class="line">m2 = a.foo</span><br><span class="line"><span class="keyword">print</span> <span class="number">1</span>, id(m1)</span><br><span class="line"><span class="keyword">print</span> <span class="number">2</span>, id(m2)</span><br></pre></td></tr></table></figure></p>
<p>输出结果为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line">&lt;function foo at <span class="number">0x023FA4B0</span>&gt;</span><br><span class="line"><span class="number">1</span> <span class="number">37725360</span></span><br><span class="line"><span class="number">2</span> <span class="number">37725360</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>结论</strong>： Static method就是在类的命名空间中的一个普通函数。</p>
</blockquote>
<h2 id="6-Functors和Operators"><a href="#6-Functors和Operators" class="headerlink" title="6. Functors和Operators"></a>6. Functors和Operators</h2><p>在C++中，重写了()操作符的类，它们实例化的对象就是一个functor，在Python中，重写了<code>__call__</code>方法的类的实例对象是一个functor。这里具体的内容就不再详述了，属于Python中比较基本的内容。<br>类似的，关于操作符（Operators），在Python中也是重载一些对应函数，比如+就是重载<code>__add__</code>函数。这里需要说的是一个性能问题，我们来看一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = <span class="number">5000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(1, 2)'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(1, 2)'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo("1", "2")'</span>, <span class="string">'from __main__ import foo'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar("1", "2")'</span>, <span class="string">'from __main__ import bar'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.689781276848</span></span><br><span class="line"><span class="number">1.40617516723</span></span><br><span class="line"><span class="number">0.806692302726</span></span><br><span class="line"><span class="number">1.4724794197</span></span><br></pre></td></tr></table></figure></p>
<p>原理上，+的操作符是调用<code>__add__</code>方法来进行处理，那为什么直接调用<code>__add__</code>方法反而会慢呢？我们使用dis模块来看一下Python代码翻译成Python虚拟机的指令的区别。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line">dis.dis(foo)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'-'</span> * <span class="number">50</span></span><br><span class="line">dis.dis(bar)</span><br></pre></td></tr></table></figure></p>
<p>输出结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">6</span> BINARY_ADD          </span><br><span class="line">              <span class="number">7</span> RETURN_VALUE        </span><br><span class="line">--------------------------------------------------</span><br><span class="line">  <span class="number">7</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">              <span class="number">3</span> LOAD_ATTR                <span class="number">0</span> (__add__)</span><br><span class="line">              <span class="number">6</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">              <span class="number">9</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">             <span class="number">12</span> RETURN_VALUE</span><br></pre></td></tr></table></figure></p>
<p>dis模块的dis方法可以打印出传入函数的虚拟机指令，可以看到foo函数使用+，并没有调用<code>__add__</code>方法，而是用了一个BINARY_ADD指令来直接进行加法。这就是它比直接调用<code>__add__</code>方法快的原因。</p>
<blockquote>
<p><strong>总结</strong>：对于Python的内建类型，操作符比直接调用对应的函数要好，Python可能会使用对应的二进制操作进行优化。</p>
<p><strong>思考</strong>: 对于用户自定义的类型呢，效率哪个更高？</p>
</blockquote>
<p>我们来看例子的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(a, b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a.__add__(b)</span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		self._value = v</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, v)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> self._value + v._value</span><br><span class="line">		</span><br><span class="line">n1 = Number(<span class="number">1</span>)</span><br><span class="line">n2 = Number(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> n1 + n2</span><br><span class="line"></span><br><span class="line">n = <span class="number">1000000</span></span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'foo(Number(1), Number(2))'</span>, <span class="string">'from __main__ import foo, Number'</span>).timeit(n)</span><br><span class="line"><span class="keyword">print</span> timeit.Timer(<span class="string">'bar(Number(1), Number(2))'</span>, <span class="string">'from __main__ import bar, Number'</span>).timeit(n)</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1.34897905469</span></span><br><span class="line"><span class="number">1.26909055996</span></span><br></pre></td></tr></table></figure></p>
<p>看上去，直接调用<code>__add__</code>方法反而更快一些，但是差别整体不大。这是因为+操作符会进行优化尝试，需要额外的时间消耗。不过呢，这点时间差别比较小，而且直接使用类似<code>__add__</code>的方法调用对于代码的可读性维护性会带来一定的困扰，因此大部分情况下，<strong>直接使用操作符会更好</strong>。</p>
<p>2016年7月8日晚于杭州网易大厦</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance3/" class="article-date">
  	<time datetime="2016-07-02T20:55:21.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance3/">Python进阶(三)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4-Bound-Method和Unbound-Method"><a href="#4-Bound-Method和Unbound-Method" class="headerlink" title="4. Bound Method和Unbound Method"></a>4. Bound Method和Unbound Method</h2><blockquote>
<p><strong>声明</strong>: 本系列文章中的所有内容都是基于Python 2.x版本的，原因是网易绝大部分项目都是在用2.x版本，笔者参与过的项目无论端游还是手游都是基于Python 2.7.x版本进行的开发，因此无论经验还是课程适用性，都是在2.x范围内。在Python 3.x中，unbound method的概念已经被取消了。</p>
</blockquote>
<p>上一小节说了，Bound Method和Unbound Method这部分是我参与大雄的课程中最喜欢的一部分，因为它让我窥探到了Python语言动态特性的一角，也加深了我对于平时在用的一种优化方法的认识。这部分会比较长，我们分几个小节来细说。</p>
<h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><p>先从代码来看，定义一个简单的类A：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure></p>
<p>很简单，我们来打印一些信息来看看：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> A.foo		<span class="comment"># &lt;unbound method A.foo&gt;</span></span><br><span class="line"><span class="keyword">print</span> a.foo		<span class="comment"># &lt;bound method A.foo of &lt;__main__.A object at 0x023DE070&gt;&gt;</span></span><br><span class="line"><span class="keyword">print</span> A.foo == a.foo <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> a, id(a)	<span class="comment">#&lt;__main__.A object at 0x0235E070&gt; 37085296</span></span><br><span class="line"><span class="keyword">print</span> A.foo.im_self	<span class="comment"># None</span></span><br><span class="line"><span class="keyword">print</span> a.foo.im_self	<span class="comment"># &lt;__main__.A object at 0x0241E070&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>为了方便对比和理解我把输出的结果放在了对应的print之后，首先输出两个<code>A.foo</code>和<code>a.foo</code>，看到了他们分别是两个对象，一个叫做unbound method，一个叫做bound method，很明显他们是两个不同的对象。这跟我从C++角度来理解Python的方法（Method）就有点不同了——通常静态语言中，面向对象的设计，把方法的定义放在类上，对象通过一定的机制（比如虚函数表等）查找到对应的函数地址来进行调用，那按这样推理，A.foo和a.foo应该是一个东西才对。事实证明Python语言不是这样的。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance3/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-pythonadvance2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/03/pythonadvance2/" class="article-date">
  	<time datetime="2016-07-02T20:54:20.000Z" itemprop="datePublished">2016-07-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/03/pythonadvance2/">Python进阶(二)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这一部分是关于Python的Callable。在Stackoverflow上有一个专门的问题叫做<a href="http://stackoverflow.com/questions/111234/what-is-a-callable-in-python">“What is a “callable” in Python”</a>，高票回答中说：</p>
<blockquote>
<p>A callable is anything that can be called.</p>
</blockquote>
<p>这个回答很抽象，大雄从更具体的角度来阐述Callable这个概念——在Python中哪些是callable的？</p>
<ul>
<li><strong>function</strong></li>
<li><strong>closure</strong></li>
<li><strong>bound method</strong></li>
<li><strong>unbound method</strong></li>
<li><strong>class method</strong></li>
<li><strong>static method</strong></li>
<li><strong>functor</strong></li>
<li><strong>operator</strong></li>
<li><strong>class</strong></li>
</ul>
<p>先说答案，很明显，列出的这些都是callable的。这些概念中的大部分我在工作中都有使用，包括比如closure的坑也帮助新同学调试bug的时候看到新入职的同学自己踩到过，但是对于<strong>bound method</strong>和<strong>unbound method</strong>这些概念还不是很清晰。我们也一个个来看。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Python/">Python</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/开发/">开发</a></li></ul>
	</div>

      

      
        <p class="article-more-link">
          <a  href="/2016/07/03/pythonadvance2/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 董夕
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>